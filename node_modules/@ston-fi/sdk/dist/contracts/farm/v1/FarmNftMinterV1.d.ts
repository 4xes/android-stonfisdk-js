import { type NftCollectionOptions } from "tonweb";
import type { Cell, Address, AddressType, QueryIdType, MessageData, AmountType, SdkContractOptions } from '../../../types';
import { FARM_VERSION } from "../constants";
declare const Cell: typeof import("tonweb/dist/types/boc/cell").Cell, Address: typeof import("tonweb/dist/types/utils/address").Address, NftCollection: typeof import("tonweb/dist/types/contract/token/nft/nft-collection").NftCollection;
export interface FarmNftMinterV1Options extends SdkContractOptions, NftCollectionOptions {
    gasConstants?: Partial<typeof FarmNftMinterV1.gasConstants>;
}
export declare class FarmNftMinterV1 extends NftCollection {
    static readonly version: FARM_VERSION;
    static readonly gasConstants: {
        stake: import("bn.js");
        stakeForward: import("bn.js");
    };
    protected readonly stonApiClient: import('../../../types').StonApiClient;
    readonly gasConstants: {
        stake: import("bn.js");
        stakeForward: import("bn.js");
    };
    constructor({ tonApiClient, stonApiClient, ...options }: FarmNftMinterV1Options);
    createStakeBody(): Promise<Cell>;
    /**
     * Build all data required to execute a jetton `stake` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.jettonAddress - Jetton address of token to be staked
     * @param {BN | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} containing all data required to execute a jetton `stake` transaction
     */
    buildStakeTxParams(params: {
        userWalletAddress: AddressType;
        jettonAddress: AddressType;
        jettonAmount: AmountType;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * @returns structure containing current state of the minter
     *
     * @property {BN} nextItemIndex - Index of the next nft in this collection
     * @property {BN} lastUpdateTime - Last time farming values were updated
     * @property {number} status - Status of the contract: uninitialized `0`, active `1`, paused `3`
     * @property {BN} depositedNanorewards - Deposited rewards in nanounits
     * @property {BN} currentStakedTokens - Number of staked tokens in basic token units
     * @property {BN} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit
     * @property {BN} accruedNanorewards - Total number of accrued rewards in nanounits
     * @property {BN} claimedNanorewards - Number of claimed rewards in nanounits
     * @property {BN} contractUniqueId - Minter id
     * @property {BN} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits
     * @property {boolean} soulboundItems - Whether minted NFTs are soulbound
     * @property {BN} minStakeTime - Minimum staking time
     * @property {Address} stakingTokenWallet - Minter's staking jetton wallet
     * @property {Address} rewardTokenWallet - Minter's reward jetton wallet
     */
    getData(): Promise<{
        nextItemIndex: import("bn.js");
        lastUpdateTime: import("bn.js");
        status: number;
        depositedNanorewards: import("bn.js");
        currentStakedTokens: import("bn.js");
        accruedPerUnitNanorewards: import("bn.js");
        accruedNanorewards: import("bn.js");
        claimedNanorewards: import("bn.js");
        contractUniqueId: import("bn.js");
        nanorewardsPer24h: import("bn.js");
        soulboundItems: boolean;
        minStakeTime: import("bn.js");
        stakingTokenWallet: import("tonweb/dist/types/utils/address").Address;
        rewardTokenWallet: import("tonweb/dist/types/utils/address").Address;
    }>;
    /**
     * @returns {Address} address of minter for staking jetton that is used for farming
     */
    getStakingJettonAddress(): Promise<Address>;
}
export {};
