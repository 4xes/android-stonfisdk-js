import a from "tonweb";
import { StonApiClient as w } from "../../../StonApiClient.js";
import { parseBoolean as g } from "../../../utils/parseBoolean.js";
import { FARM_VERSION as l, FARM_OP_CODES as r } from "../constants.js";
const {
  boc: { Cell: d },
  utils: { BN: o, Address: u },
  token: {
    nft: { NftItem: y }
  }
} = a, i = class c extends y {
  constructor({
    tonApiClient: t,
    stonApiClient: e,
    gasConstants: n,
    ...s
  }) {
    super(t, s), this.stonApiClient = e ?? new w(t), this.gasConstants = {
      ...c.gasConstants,
      ...n
    };
  }
  async createClaimRewardsBody(t) {
    const e = new d();
    return e.bits.writeUint(r.CLAIM_REWARDS, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
  }
  /**
   * Build all data required to execute a `claim_rewards` transaction.
   *
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `claim_rewards` transaction.
   */
  async buildClaimRewardsTxParams(t) {
    const e = await this.getAddress(), n = await this.createClaimRewardsBody({
      queryId: t == null ? void 0 : t.queryId
    }), s = new o(
      (t == null ? void 0 : t.gasAmount) ?? this.gasConstants.claimRewards
    );
    return {
      to: new u(e.toString(!0, !0, !0)),
      payload: n,
      gasAmount: s
    };
  }
  async createUnstakeBody(t) {
    const e = new d();
    return e.bits.writeUint(r.UNSTAKE, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
  }
  /**
   * Build all data required to execute a `unstake` transaction.
   *
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `unstake` transaction.
   */
  async buildUnstakeTxParams(t) {
    const e = await this.getAddress(), n = await this.createUnstakeBody({
      queryId: t == null ? void 0 : t.queryId
    }), s = new o((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.unstake);
    return {
      to: new u(e.toString(!0, !0, !0)),
      payload: n,
      gasAmount: s
    };
  }
  /**
   * @returns structure containing current state of the farm NFT
   *
   * @property {number} status Status of the contract: uninitialized `0`, active `1`, unstaked `2`, claiming `3`
   * @property {boolean} isSoulbound If nft is soulbound
   * @property {BN} stakedTokens Amount of staked tokens
   * @property {BN} claimedPerUnitNanorewards `accrued_per_unit_nanorewards` at the time the user made the stake or last claimed rewards
   */
  async getFarmingData() {
    const t = await this.getAddress(), e = await this.provider.call2(
      t.toString(),
      "get_farming_data"
    );
    return {
      status: e[0].toNumber(),
      isSoulbound: g(e[1]),
      stakedTokens: e[2],
      claimedPerUnitNanorewards: e[3]
    };
  }
};
i.version = l.v1;
i.gasConstants = {
  claimRewards: new o("300000000"),
  unstake: new o("400000000"),
  destroy: new o("50000000")
};
let f = i;
export {
  f as FarmNftItemV1
};
//# sourceMappingURL=FarmNftItemV1.js.map
