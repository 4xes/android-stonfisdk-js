import w from "tonweb";
import { StonApiClient as m } from "../../../StonApiClient.js";
import { parseAddressNotNull as a } from "../../../utils/parseAddress.js";
import { parseBoolean as g } from "../../../utils/parseBoolean.js";
import { createJettonTransferMessage as A } from "../../../utils/createJettonTransferMessage.js";
import { FARM_VERSION as k, FARM_OP_CODES as f } from "../constants.js";
const {
  boc: { Cell: S },
  utils: { Address: o, BN: n },
  token: {
    nft: { NftCollection: N },
    jetton: { JettonWallet: h }
  }
} = w, r = class d extends N {
  constructor({
    tonApiClient: e,
    stonApiClient: t,
    ...s
  }) {
    super(e, s), this.stonApiClient = t ?? new m(e), this.gasConstants = {
      ...d.gasConstants,
      ...s.gasConstants
    };
  }
  async createStakeBody() {
    const e = new S();
    return e.bits.writeUint(f.STAKE, 32), e;
  }
  /**
   * Build all data required to execute a jetton `stake` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked
   * @param {BN | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} containing all data required to execute a jetton `stake` transaction
   */
  async buildStakeTxParams(e) {
    const [t, s, i] = await Promise.all([
      (async () => new o(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: e.jettonAddress.toString(),
          ownerAddress: e.userWalletAddress.toString()
        })
      ))(),
      this.createStakeBody(),
      this.getAddress()
    ]), l = new n(
      e.forwardGasAmount ?? this.gasConstants.stakeForward
    ), c = A({
      queryId: e.queryId ?? 0,
      amount: e.jettonAmount,
      destination: i,
      responseDestination: e.userWalletAddress,
      forwardTonAmount: l,
      forwardPayload: s
    }), u = new n(e.gasAmount ?? this.gasConstants.stake);
    return {
      to: new o(t.toString(!0, !0, !0)),
      payload: c,
      gasAmount: u
    };
  }
  /**
   * @returns structure containing current state of the minter
   *
   * @property {BN} nextItemIndex - Index of the next nft in this collection
   * @property {BN} lastUpdateTime - Last time farming values were updated
   * @property {number} status - Status of the contract: uninitialized `0`, active `1`, paused `3`
   * @property {BN} depositedNanorewards - Deposited rewards in nanounits
   * @property {BN} currentStakedTokens - Number of staked tokens in basic token units
   * @property {BN} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit
   * @property {BN} accruedNanorewards - Total number of accrued rewards in nanounits
   * @property {BN} claimedNanorewards - Number of claimed rewards in nanounits
   * @property {BN} contractUniqueId - Minter id
   * @property {BN} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits
   * @property {boolean} soulboundItems - Whether minted NFTs are soulbound
   * @property {BN} minStakeTime - Minimum staking time
   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet
   * @property {Address} rewardTokenWallet - Minter's reward jetton wallet
   */
  async getData() {
    const e = await this.getAddress(), t = await this.provider.call2(
      e.toString(),
      "get_farming_minter_data"
    );
    return {
      nextItemIndex: t[0],
      lastUpdateTime: t[1],
      status: t[2].toNumber(),
      depositedNanorewards: t[3],
      currentStakedTokens: t[4],
      accruedPerUnitNanorewards: t[5],
      accruedNanorewards: t[6],
      claimedNanorewards: t[7],
      contractUniqueId: t[8],
      nanorewardsPer24h: t[9],
      soulboundItems: g(t[10]),
      minStakeTime: t[11],
      stakingTokenWallet: a(t[12]),
      rewardTokenWallet: a(t[13])
    };
  }
  /**
   * @returns {Address} address of minter for staking jetton that is used for farming
   */
  async getStakingJettonAddress() {
    const { stakingTokenWallet: e } = await this.getData(), t = new h(this.provider, {
      address: e
    }), { jettonMinterAddress: s } = await t.getData();
    return s;
  }
};
r.version = k.v1;
r.gasConstants = {
  stake: new n("300000000"),
  stakeForward: new n("250000000")
};
let F = r;
export {
  F as FarmNftMinterV1
};
//# sourceMappingURL=FarmNftMinterV1.js.map
