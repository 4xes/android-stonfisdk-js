import h from "tonweb";
import { StonApiClient as C } from "../../../StonApiClient.js";
import { parseAddress as N, parseAddressNotNull as g } from "../../../utils/parseAddress.js";
import { parseBoolean as m } from "../../../utils/parseBoolean.js";
import { parseString as k } from "../../../utils/parseString.js";
import { createJettonTransferMessage as S } from "../../../utils/createJettonTransferMessage.js";
import { parseDictionaryCell as A } from "../../../utils/parseDictionary/index.js";
import { parseCell as p } from "../../../utils/parseCell.js";
import { FARM_VERSION as D, FARM_OP_CODES as y } from "../constants.js";
const {
  boc: { Cell: U },
  utils: { Address: l, BN: u },
  token: {
    nft: { NftCollection: T },
    jetton: { JettonWallet: F }
  }
} = h, w = class f extends T {
  constructor({
    tonApiClient: e,
    stonApiClient: t,
    gasConstants: a,
    ...n
  }) {
    super(e, n), this.stonApiClient = t ?? new C(e), this.gasConstants = {
      ...f.gasConstants,
      ...a
    };
  }
  async createStakeBody(e) {
    const t = new U();
    return t.bits.writeUint(y.STAKE, 32), t.bits.writeAddress(
      e != null && e.ownerAddress ? new l(e.ownerAddress) : void 0
    ), t;
  }
  /**
   * Build all data required to execute a jetton `stake` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked
   * @param {BN | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)
   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain
   * @param {Address | string} params.ownerAddress - Optional; custom owner of stake; if undefined stake owner is sender address
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} containing all data required to execute a jetton `stake` transaction
   */
  async buildStakeTxParams(e) {
    const [t, a, n, i] = await Promise.all([
      (async () => new l(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: e.jettonAddress.toString(),
          ownerAddress: e.userWalletAddress.toString()
        })
      ))(),
      this.createStakeBody({
        ownerAddress: e.ownerAddress
      }),
      this.getAddress(),
      (async () => e.poolCount ?? (await this.getData()).poolCount)()
    ]), o = this.gasConstants.stakeFwdBase.add(
      this.gasConstants.stakeFwdPerPool.muln(i + 1)
    ), r = S({
      queryId: e.queryId ?? 0,
      amount: e.jettonAmount,
      destination: n,
      responseDestination: e.userWalletAddress,
      forwardTonAmount: o,
      forwardPayload: a
    }), d = o.add(this.gasConstants.stake);
    return {
      to: new l(t.toString(!0, !0, !0)),
      payload: r,
      gasAmount: d
    };
  }
  /**
   * @returns {Address} address of minter for staking jetton that is used for farming
   */
  async getStakingJettonAddress() {
    const { stakingTokenWallet: e } = await this.getData(), t = new F(this.provider, {
      address: e
    }), { jettonMinterAddress: a } = await t.getData();
    return a;
  }
  /**
   * @returns structure containing pending data
   *
   * @property {BN} changeCustodianTs - Timestamp when 'change_custodian' was initiated
   * @property {BN} sendMsgTs - Timestamp when 'send_raw_msg' was initiated
   * @property {BN} codeUpgradeTs - Timestamp when 'code_upgrade' was initiated
   * @property {Address} newCustodian - New custodian that will be set after confirmation
   * @property {Cell} pendingMsg - Pending msg that will be sends after confirmation
   * @property {Cell} newCode - New contract code that will be set after confirmation
   * @property {Cell} newStorage - New contract storage that will be set after confirmation
   */
  async getPendingData() {
    const e = await this.getAddress(), t = await this.provider.call2(
      e.toString(),
      "get_pending_data"
    );
    return {
      changeCustodianTs: t[0],
      sendMsgTs: t[1],
      codeUpgradeTs: t[2],
      newCustodian: N(t[3]),
      pendingMsg: t[4],
      newCode: t[5],
      newStorage: t[6]
    };
  }
  /**
   * @returns structure containing version data
   *
   * @property {number} major - Major version; breaking changes in api
   * @property {number} minor - Minor version; non-breaking new functionality
   * @property {string} development - Development version; can contain breaking changes
   */
  async getVersion() {
    const e = await this.getAddress(), t = await this.provider.call2(
      e.toString(),
      "get_version"
    );
    return {
      major: t[0].toNumber(),
      minor: t[1].toNumber(),
      development: k(t[2])
    };
  }
  /**
   * @returns structure containing current state of the minter
   *
   * @property {BN} nextItemIndex - Index of the next nft in this collection
   * @property {number} status - Status of the contract: uninitialized `0`, operational `1`, pause_all `2`, frozen `3`, retired `4`,
   * @property {number} poolCount - Pools count
   * @property {BN} currentStakedTokens - Number of staked tokens in basic token units
   * @property {BN} contractUniqueId - Minter id
   * @property {BN} minStakeTime - Minimum staking time
   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet
   * @property {Address} custodianAddress - Custodian address
   * @property {boolean} canChangeCustodian - If can change custodian
   * @property {boolean} canSendRawMsg - If admin can send arbitrary raw msg from Minter
   * @property {Map<number, FarmDataAccrued>} farmDataAccrued - Accrued data for pools
   * @property {Map<number, FarmDataParameters>} farmDataParameters - Pools parameters
   */
  async getData() {
    const e = await this.getAddress(), t = await this.provider.call2(
      e.toString(),
      "get_farming_minter_data"
    ), a = A(t[10], 8), n = /* @__PURE__ */ new Map();
    a.forEach((r, d) => {
      const s = p(r), c = {
        depositedNanorewards: s.loadUint(150),
        accruedPerUnitNanorewards: s.loadUint(150),
        accruedFeeNanorewards: s.loadUint(150),
        claimedNanorewards: s.loadUint(150),
        claimedFeeNanorewards: s.loadUint(150),
        accruedNanorewards: s.loadUint(150),
        lastUpdateTime: s.loadUint(64)
      };
      n.set(Number(d), c);
    });
    const i = A(t[11], 8), o = /* @__PURE__ */ new Map();
    return i.forEach((r, d) => {
      const s = p(r), c = {
        adminFee: s.loadUint(16),
        nanorewardsPer24h: s.loadUint(150),
        unrestrictedDepositRewards: s.loadBit(),
        rewardTokenWallet: s.loadAddress(),
        canChangeFee: s.loadBit(),
        status: s.loadUint(8).toNumber()
      };
      o.set(Number(d), c);
    }), {
      nextItemIndex: t[0],
      status: t[1].toNumber(),
      poolCount: t[2].toNumber(),
      currentStakedTokens: t[3],
      contractUniqueId: t[4],
      minStakeTime: t[5],
      stakingTokenWallet: g(t[6]),
      custodianAddress: g(t[7]),
      canChangeCustodian: m(t[8]),
      canSendRawMsg: m(t[9]),
      farmDataAccrued: n,
      farmDataParameters: o
    };
  }
};
w.version = D.v3;
w.gasConstants = {
  stakeFwdBase: new u("210000000"),
  stakeFwdPerPool: new u("15000000"),
  stake: new u("100000000")
};
let x = w;
export {
  x as FarmNftMinterV3
};
//# sourceMappingURL=FarmNftMinterV3.js.map
