{"version":3,"file":"FarmNftMinterV3.js","sources":["../../../../src/contracts/farm/v3/FarmNftMinterV3.ts"],"sourcesContent":["import TonWeb, { type NftCollectionOptions } from \"tonweb\";\n\nimport type {\n  BN,\n  Cell,\n  Address,\n  AddressType,\n  QueryIdType,\n  MessageData,\n  AmountType,\n  SdkContractOptions,\n} from \"@/types\";\nimport { StonApiClient } from \"@/StonApiClient\";\nimport { parseAddress, parseAddressNotNull } from \"@/utils/parseAddress\";\nimport { parseBoolean } from \"@/utils/parseBoolean\";\nimport { parseString } from \"@/utils/parseString\";\nimport { createJettonTransferMessage } from \"@/utils/createJettonTransferMessage\";\nimport { parseDictionaryCell } from \"@/utils/parseDictionary\";\nimport { parseCell } from \"@/utils/parseCell\";\n\nimport { FARM_OP_CODES, FARM_VERSION } from \"../constants\";\n\nconst {\n  boc: { Cell },\n  utils: { Address, BN },\n  token: {\n    nft: { NftCollection },\n    jetton: { JettonWallet },\n  },\n} = TonWeb;\n\n/**\n *  @type {FarmDataAccrued} represent state of the accrued data for pool\n *\n * @property {BN} depositedNanorewards - Deposited rewards in nanounits\n * @property {BN} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit\n * @property {BN} accruedFeeNanorewards - Accrued fees\n * @property {BN} claimedNanorewards - Number of claimed rewards in nanounits\n * @property {BN} claimedFeeNanorewards - Claimed fees\n * @property {BN} accruedNanorewards - Total number of accrued rewards in nanounits\n * @property {BN} lastUpdateTime - Last time farming values were updated\n */\nexport type FarmDataAccrued = {\n  depositedNanorewards: BN;\n  accruedPerUnitNanorewards: BN;\n  accruedFeeNanorewards: BN;\n  claimedNanorewards: BN;\n  claimedFeeNanorewards: BN;\n  accruedNanorewards: BN;\n  lastUpdateTime: BN;\n};\n\n/**\n *  @type {FarmDataParameters} represent state of the pool parameters\n *\n * @property {BN} adminFee - Admin fee; divider is 10000\n * @property {BN} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits\n * @property {boolean} unrestrictedDepositRewards - If rewards can be deposited by anyone\n * @property {Address} rewardTokenWallet - Minter's reward jetton wallet\n * @property {boolean} canChangeFee - If can change fee\n * @property {BN} status - Status of the contract\n */\nexport type FarmDataParameters = {\n  adminFee: BN;\n  nanorewardsPer24h: BN;\n  unrestrictedDepositRewards: boolean;\n  rewardTokenWallet: Address;\n  canChangeFee: boolean;\n  status: number;\n};\n\nexport interface FarmNftMinterV3Options\n  extends SdkContractOptions,\n    NftCollectionOptions {\n  address: Required<NftCollectionOptions>[\"address\"];\n  gasConstants?: Partial<typeof FarmNftMinterV3.gasConstants>;\n}\n\nexport class FarmNftMinterV3 extends NftCollection {\n  public static readonly version: FARM_VERSION = FARM_VERSION.v3;\n\n  public static readonly gasConstants = {\n    stakeFwdBase: new BN(\"210000000\"),\n    stakeFwdPerPool: new BN(\"15000000\"),\n    stake: new BN(\"100000000\"),\n  };\n\n  protected readonly stonApiClient;\n\n  public readonly gasConstants;\n\n  constructor({\n    tonApiClient,\n    stonApiClient,\n    gasConstants,\n    ...options\n  }: FarmNftMinterV3Options) {\n    super(tonApiClient, options);\n\n    this.stonApiClient = stonApiClient ?? new StonApiClient(tonApiClient);\n    this.gasConstants = {\n      ...FarmNftMinterV3.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createStakeBody(params?: {\n    ownerAddress?: AddressType;\n  }): Promise<Cell> {\n    const payload = new Cell();\n\n    payload.bits.writeUint(FARM_OP_CODES.STAKE, 32);\n    payload.bits.writeAddress(\n      params?.ownerAddress ? new Address(params.ownerAddress) : undefined,\n    );\n\n    return payload;\n  }\n\n  /**\n   * Build all data required to execute a jetton `stake` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked\n   * @param {BN | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)\n   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain\n   * @param {Address | string} params.ownerAddress - Optional; custom owner of stake; if undefined stake owner is sender address\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} containing all data required to execute a jetton `stake` transaction\n   */\n  public async buildStakeTxParams(params: {\n    userWalletAddress: AddressType;\n    jettonAddress: AddressType;\n    jettonAmount: AmountType;\n    poolCount?: number;\n    ownerAddress?: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const [jettonWalletAddress, forwardPayload, address, poolCount] =\n      await Promise.all([\n        (async () =>\n          new Address(\n            await this.stonApiClient.getJettonWalletAddress({\n              jettonAddress: params.jettonAddress.toString(),\n              ownerAddress: params.userWalletAddress.toString(),\n            }),\n          ))(),\n        this.createStakeBody({\n          ownerAddress: params.ownerAddress,\n        }),\n        this.getAddress(),\n        (async () => params.poolCount ?? (await this.getData()).poolCount)(),\n      ]);\n\n    const forwardTonAmount = this.gasConstants.stakeFwdBase.add(\n      this.gasConstants.stakeFwdPerPool.muln(poolCount + 1),\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.jettonAmount,\n      destination: address,\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = forwardTonAmount.add(this.gasConstants.stake);\n\n    return {\n      to: new Address(jettonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * @returns {Address} address of minter for staking jetton that is used for farming\n   */\n  public async getStakingJettonAddress(): Promise<Address> {\n    const { stakingTokenWallet } = await this.getData();\n\n    const jettonWallet = new JettonWallet(this.provider, {\n      address: stakingTokenWallet,\n    });\n\n    const { jettonMinterAddress } = await jettonWallet.getData();\n\n    return jettonMinterAddress;\n  }\n\n  /**\n   * @returns structure containing pending data\n   *\n   * @property {BN} changeCustodianTs - Timestamp when 'change_custodian' was initiated\n   * @property {BN} sendMsgTs - Timestamp when 'send_raw_msg' was initiated\n   * @property {BN} codeUpgradeTs - Timestamp when 'code_upgrade' was initiated\n   * @property {Address} newCustodian - New custodian that will be set after confirmation\n   * @property {Cell} pendingMsg - Pending msg that will be sends after confirmation\n   * @property {Cell} newCode - New contract code that will be set after confirmation\n   * @property {Cell} newStorage - New contract storage that will be set after confirmation\n   */\n  public async getPendingData() {\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_pending_data\",\n    );\n\n    return {\n      changeCustodianTs: result[0] as BN,\n      sendMsgTs: result[1] as BN,\n      codeUpgradeTs: result[2] as BN,\n      newCustodian: parseAddress(result[3]),\n      pendingMsg: result[4] as Cell,\n      newCode: result[5] as Cell,\n      newStorage: result[6] as Cell,\n    };\n  }\n\n  /**\n   * @returns structure containing version data\n   *\n   * @property {number} major - Major version; breaking changes in api\n   * @property {number} minor - Minor version; non-breaking new functionality\n   * @property {string} development - Development version; can contain breaking changes\n   */\n  public async getVersion() {\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_version\",\n    );\n\n    return {\n      major: (result[0] as BN).toNumber(),\n      minor: (result[1] as BN).toNumber(),\n      development: parseString(result[2]),\n    };\n  }\n\n  /**\n   * @returns structure containing current state of the minter\n   *\n   * @property {BN} nextItemIndex - Index of the next nft in this collection\n   * @property {number} status - Status of the contract: uninitialized `0`, operational `1`, pause_all `2`, frozen `3`, retired `4`,\n   * @property {number} poolCount - Pools count\n   * @property {BN} currentStakedTokens - Number of staked tokens in basic token units\n   * @property {BN} contractUniqueId - Minter id\n   * @property {BN} minStakeTime - Minimum staking time\n   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet\n   * @property {Address} custodianAddress - Custodian address\n   * @property {boolean} canChangeCustodian - If can change custodian\n   * @property {boolean} canSendRawMsg - If admin can send arbitrary raw msg from Minter\n   * @property {Map<number, FarmDataAccrued>} farmDataAccrued - Accrued data for pools\n   * @property {Map<number, FarmDataParameters>} farmDataParameters - Pools parameters\n   */\n  public async getData() {\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_farming_minter_data\",\n    );\n\n    const farmDataAccruedDict = parseDictionaryCell(result[10] as Cell, 8);\n    const farmDataAccrued = new Map<number, FarmDataAccrued>();\n\n    farmDataAccruedDict.forEach((cell, poolIndex) => {\n      const slice = parseCell(cell);\n      const accruedData = {\n        depositedNanorewards: slice.loadUint(150),\n        accruedPerUnitNanorewards: slice.loadUint(150),\n        accruedFeeNanorewards: slice.loadUint(150),\n        claimedNanorewards: slice.loadUint(150),\n        claimedFeeNanorewards: slice.loadUint(150),\n        accruedNanorewards: slice.loadUint(150),\n        lastUpdateTime: slice.loadUint(64),\n      };\n\n      farmDataAccrued.set(Number(poolIndex), accruedData);\n    });\n\n    const farmDataParametersDict = parseDictionaryCell(result[11] as Cell, 8);\n    const farmDataParameters = new Map<number, FarmDataParameters>();\n\n    farmDataParametersDict.forEach((cell, poolIndex) => {\n      const slice = parseCell(cell);\n      const parametersData = {\n        adminFee: slice.loadUint(16),\n        nanorewardsPer24h: slice.loadUint(150),\n        unrestrictedDepositRewards: slice.loadBit(),\n        rewardTokenWallet: slice.loadAddress(),\n        canChangeFee: slice.loadBit(),\n        status: slice.loadUint(8).toNumber(),\n      };\n\n      farmDataParameters.set(Number(poolIndex), parametersData);\n    });\n\n    return {\n      nextItemIndex: result[0] as BN,\n      status: (result[1] as BN).toNumber(),\n      poolCount: (result[2] as BN).toNumber(),\n      currentStakedTokens: result[3] as BN,\n      contractUniqueId: result[4] as BN,\n      minStakeTime: result[5] as BN,\n      stakingTokenWallet: parseAddressNotNull(result[6]),\n      custodianAddress: parseAddressNotNull(result[7]),\n      canChangeCustodian: parseBoolean(result[8]),\n      canSendRawMsg: parseBoolean(result[9]),\n      farmDataAccrued: farmDataAccrued,\n      farmDataParameters: farmDataParameters,\n    };\n  }\n}\n"],"names":["Cell","Address","BN","NftCollection","JettonWallet","TonWeb","_FarmNftMinterV3","tonApiClient","stonApiClient","gasConstants","options","StonApiClient","params","payload","FARM_OP_CODES","jettonWalletAddress","forwardPayload","address","poolCount","forwardTonAmount","createJettonTransferMessage","gasAmount","stakingTokenWallet","jettonWallet","jettonMinterAddress","contractAddress","result","parseAddress","parseString","farmDataAccruedDict","parseDictionaryCell","farmDataAccrued","cell","poolIndex","slice","parseCell","accruedData","farmDataParametersDict","farmDataParameters","parametersData","parseAddressNotNull","parseBoolean","FARM_VERSION","FarmNftMinterV3"],"mappings":"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"}