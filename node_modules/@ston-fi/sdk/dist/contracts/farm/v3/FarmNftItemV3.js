import w from "tonweb";
import { StonApiClient as y } from "../../../StonApiClient.js";
import { createSbtDestroyMessage as m } from "../../../utils/createSbtDestroyMessage.js";
import { parseAddressNotNull as g } from "../../../utils/parseAddress.js";
import { parseDictionaryUint as C } from "../../../utils/parseDictionary/index.js";
import { FARM_VERSION as A, FARM_OP_CODES as d } from "../constants.js";
import { FarmNftMinterV3 as h } from "./FarmNftMinterV3.js";
const {
  boc: { Cell: c },
  utils: { BN: r, Address: i },
  token: {
    nft: { NftItem: I }
  }
} = w, a = class l extends I {
  constructor({
    tonApiClient: t,
    stonApiClient: e,
    gasConstants: s,
    ...o
  }) {
    super(t, o), this.stonApiClient = e ?? new y(t), this.gasConstants = {
      ...l.gasConstants,
      ...s
    };
  }
  async createClaimRewardsBody(t) {
    const e = new c();
    return e.bits.writeUint(d.CLAIM_REWARDS, 32), e.bits.writeUint(t.queryId ?? 0, 64), t.claimAll ? (e.bits.writeUint(1, 1), e.bits.writeUint(0, 8)) : (e.bits.writeUint(0, 1), e.bits.writeUint(t.poolIndex, 8)), e;
  }
  /**
   * Build all data required to execute a `claim_rewards` transaction.
   *
   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain
   * @param {number | undefined} params.poolIndex - Optional; farm reward pool index used for claiming; If undefined claim rewards from all pools
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `claim_rewards` transaction.
   */
  async buildClaimRewardsTxParams(t) {
    const e = await this.getAddress(), s = await this.createClaimRewardsBody({
      queryId: t.queryId,
      claimAll: t.poolIndex === void 0,
      poolIndex: t.poolIndex ?? 0
    }), o = t.poolCount ?? await this.getPoolCount(), n = this.gasConstants.claimRewardsBase.add(
      this.gasConstants.claimRewardsPerPool.muln(o - 1)
    );
    return {
      to: new i(e.toString(!0, !0, !0)),
      payload: s,
      gasAmount: n
    };
  }
  async createUnstakeBody(t) {
    const e = new c();
    return e.bits.writeUint(d.UNSTAKE, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
  }
  /**
   * Build all data required to execute a `unstake` transaction.
   *
   * @param {number | undefined} params.poolCount -  Optional; Number of deployed farm reward pools; If undefined value will get onchain
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `unstake` transaction.
   */
  async buildUnstakeTxParams(t) {
    const e = await this.getAddress(), s = await this.createUnstakeBody({
      queryId: t.queryId
    }), o = t.poolCount ?? await this.getPoolCount(), n = this.gasConstants.unstakeBase.add(
      this.gasConstants.unstakePerPool.muln(o - 1)
    );
    return {
      to: new i(e.toString(!0, !0, !0)),
      payload: s,
      gasAmount: n
    };
  }
  async createDestroyBody(t) {
    return m({
      queryId: (t == null ? void 0 : t.queryId) ?? 0
    });
  }
  /**
   * Build all data required to execute a `destroy` transaction.
   *
   * @param {BN | string | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `destroy` transaction.
   */
  async buildDestroyTxParams(t) {
    const e = await this.getAddress(), s = await this.createDestroyBody({
      queryId: t == null ? void 0 : t.queryId
    }), o = this.gasConstants.destroy;
    return {
      to: new i(e.toString(!0, !0, !0)),
      payload: s,
      gasAmount: o
    };
  }
  /**
   * @returns structure containing current state of the farm NFT
   *
   * @property {number} status Status of the contract: uninitialized (0), active (1), unstaked (2), claiming (3), unstaked_pending (4)
   * @property {BN} revokeTime Timestamp of unstake
   * @property {BN} stakedTokens Amount of staked tokens
   * @property {BN} stakeDate Timestamp in which the owner started staking
   * @property {Map<number, BN>} claimedPerUnit `accrued_per_unit_nanorewards amounts` for each pool at the time of last claim for this user
   * @property {Address} ownerAddress Owner address of farm nft
   */
  async getFarmingData() {
    const t = await this.getAddress(), e = await this.provider.call2(
      t.toString(),
      "get_farming_data"
    ), s = C(e[4], 8, 150), o = /* @__PURE__ */ new Map();
    return s.forEach((n, u) => {
      o.set(Number(u), n);
    }), {
      status: e[0].toNumber(),
      revokeTime: e[1],
      stakedTokens: e[2],
      stakeDate: e[3],
      claimedPerUnit: o,
      ownerAddress: g(e[5])
    };
  }
  async getPoolCount() {
    const { collectionAddress: t } = await this.getData(), e = new h({
      tonApiClient: this.provider,
      stonApiClient: this.stonApiClient,
      address: t
    }), { poolCount: s } = await e.getData();
    return s;
  }
};
a.version = A.v3;
a.gasConstants = {
  claimRewardsBase: new r("350000000"),
  claimRewardsPerPool: new r("130000000"),
  unstakeBase: new r("450000000"),
  unstakePerPool: new r("130000000"),
  destroy: new r("50000000")
};
let N = a;
export {
  N as FarmNftItemV3
};
//# sourceMappingURL=FarmNftItemV3.js.map
