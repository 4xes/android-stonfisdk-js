{"version":3,"file":"RouterV1.js","sources":["../../../../src/contracts/dex/v1/RouterV1.ts"],"sourcesContent":["import TonWeb, { type ContractOptions } from \"tonweb\";\n\nimport type {\n  BN,\n  Cell,\n  MessageData,\n  AddressType,\n  QueryIdType,\n  AmountType,\n  SdkContractOptions,\n} from \"@/types\";\nimport { StonApiClient } from \"@/StonApiClient\";\nimport { createJettonTransferMessage } from \"@/utils/createJettonTransferMessage\";\nimport { parseAddress, parseAddressNotNull } from \"@/utils/parseAddress\";\nimport { parseBoolean } from \"@/utils/parseBoolean\";\n\nimport { DEX_VERSION, DEX_OP_CODES } from \"../constants\";\n\nimport { PoolV1 } from \"./PoolV1\";\n\nconst {\n  utils: { BN, bytesToBase64 },\n  boc: { Cell },\n  Address,\n  Contract,\n  token: {\n    jetton: { JettonMinter },\n  },\n} = TonWeb;\n\nexport interface RouterV1Options extends SdkContractOptions, ContractOptions {\n  gasConstants?: Partial<typeof RouterV1.gasConstants>;\n}\n\n/**\n * The router is the contract that acts as an entrypoint for all DEX calls.\n * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.\n * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,\n * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.\n * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.\n */\nexport class RouterV1 extends Contract {\n  public static readonly version = DEX_VERSION.v1;\n  public static readonly address = new Address(\n    \"EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt\",\n  );\n  public static readonly gasConstants = {\n    swapJettonToJetton: {\n      gasAmount: new BN(\"265000000\"),\n      forwardGasAmount: new BN(\"205000000\"),\n    },\n    swapJettonToTon: {\n      gasAmount: new BN(\"185000000\"),\n      forwardGasAmount: new BN(\"125000000\"),\n    },\n    swapTonToJetton: {\n      forwardGasAmount: new BN(\"215000000\"),\n    },\n    provideLpJetton: {\n      gasAmount: new BN(\"300000000\"),\n      forwardGasAmount: new BN(\"240000000\"),\n    },\n    provideLpTon: {\n      forwardGasAmount: new BN(\"260000000\"),\n    },\n  };\n\n  protected readonly stonApiClient;\n\n  public readonly gasConstants;\n\n  constructor({\n    tonApiClient,\n    stonApiClient,\n    gasConstants,\n    ...options\n  }: RouterV1Options) {\n    super(tonApiClient, {\n      ...options,\n      address: options.address ?? RouterV1.address,\n    });\n\n    this.stonApiClient = stonApiClient ?? new StonApiClient(tonApiClient);\n    this.gasConstants = {\n      ...RouterV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createSwapBody(params: {\n    userWalletAddress: AddressType;\n    minAskAmount: AmountType;\n    askJettonWalletAddress: AddressType;\n    referralAddress?: AddressType;\n  }): Promise<Cell> {\n    const payload = new Cell();\n\n    payload.bits.writeUint(DEX_OP_CODES.SWAP, 32);\n    payload.bits.writeAddress(new Address(params.askJettonWalletAddress));\n    payload.bits.writeCoins(new BN(params.minAskAmount));\n    payload.bits.writeAddress(new Address(params.userWalletAddress));\n\n    if (params.referralAddress) {\n      payload.bits.writeUint(1, 1);\n      payload.bits.writeAddress(new Address(params.referralAddress));\n    } else {\n      payload.bits.writeUint(0, 1);\n    }\n\n    return payload;\n  }\n\n  /**\n   * Build all data required to execute a jetton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `swap` transaction\n   */\n  public async buildSwapJettonToJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    offerJettonAddress: AddressType;\n    askJettonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    referralAddress?: AddressType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [offerJettonWalletAddress, askJettonWalletAddress] =\n      await Promise.all([\n        (async () =>\n          new Address(\n            await this.stonApiClient.getJettonWalletAddress({\n              jettonAddress: params.offerJettonAddress.toString(),\n              ownerAddress: params.userWalletAddress.toString(),\n            }),\n          ))(),\n        (async () =>\n          new Address(\n            await this.stonApiClient.getJettonWalletAddress({\n              jettonAddress: params.askJettonAddress.toString(),\n              ownerAddress: contractAddress.toString(),\n            }),\n          ))(),\n      ]);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ??\n        this.gasConstants.swapJettonToJetton.forwardGasAmount,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: contractAddress,\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(\n      params.gasAmount ?? this.gasConstants.swapJettonToJetton.gasAmount,\n    );\n\n    return {\n      to: new Address(offerJettonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Build all data required to execute a jetton to ton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `swap` transaction\n   */\n  public async buildSwapJettonToTonTxParams(params: {\n    userWalletAddress: AddressType;\n    offerJettonAddress: AddressType;\n    proxyTonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    referralAddress?: AddressType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    return await this.buildSwapJettonToJettonTxParams({\n      ...params,\n      askJettonAddress: params.proxyTonAddress,\n      gasAmount:\n        params.gasAmount ?? this.gasConstants.swapJettonToTon.gasAmount,\n      forwardGasAmount:\n        params.forwardGasAmount ??\n        this.gasConstants.swapJettonToTon.forwardGasAmount,\n    });\n  }\n\n  /**\n   * Build all data required to execute a ton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; Referral address\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a ton to jetton `swap` transaction\n   */\n  public async buildSwapTonToJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    proxyTonAddress: AddressType;\n    askJettonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    referralAddress?: AddressType | undefined;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [proxyTonWalletAddress, askJettonWalletAddress] = await Promise.all([\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.proxyTonAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.askJettonAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n    ]);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ??\n        this.gasConstants.swapTonToJetton.forwardGasAmount,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: contractAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.offerAmount).add(forwardTonAmount);\n\n    return {\n      to: new Address(proxyTonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  public async createProvideLiquidityBody(params: {\n    routerWalletAddress: AddressType;\n    minLpOut: AmountType;\n  }): Promise<Cell> {\n    const payload = new Cell();\n\n    payload.bits.writeUint(DEX_OP_CODES.PROVIDE_LIQUIDITY, 32);\n    payload.bits.writeAddress(new Address(params.routerWalletAddress));\n    payload.bits.writeCoins(new BN(params.minLpOut));\n\n    return payload;\n  }\n\n  /**\n   * Collect all data required to execute a jetton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `provide_lp` transaction\n   */\n  public async buildProvideLiquidityJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    sendTokenAddress: AddressType;\n    otherTokenAddress: AddressType;\n    sendAmount: AmountType;\n    minLpOut: AmountType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [jettonWalletAddress, routerWalletAddress] = await Promise.all([\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.sendTokenAddress.toString(),\n            ownerAddress: params.userWalletAddress.toString(),\n          }),\n        ))(),\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.otherTokenAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n    ]);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpJetton.forwardGasAmount,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: contractAddress,\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(\n      params.gasAmount ?? this.gasConstants.provideLpJetton.gasAmount,\n    );\n\n    return {\n      to: new Address(jettonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Collect all data required to execute a proxy ton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction\n   */\n  public async buildProvideLiquidityTonTxParams(params: {\n    userWalletAddress: AddressType;\n    proxyTonAddress: AddressType;\n    otherTokenAddress: AddressType;\n    sendAmount: AmountType;\n    minLpOut: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [proxyTonWalletAddress, routerWalletAddress] = await Promise.all([\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.proxyTonAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.otherTokenAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n    ]);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpTon.forwardGasAmount,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: contractAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.sendAmount).add(forwardTonAmount);\n\n    return {\n      to: new Address(proxyTonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.\n   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.\n   *\n   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton\n   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton\n   *\n   * @returns {Address | null} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddress(params: {\n    token0: AddressType;\n    token1: AddressType;\n  }) {\n    const cellA = new Cell();\n    cellA.bits.writeAddress(new Address(params.token0));\n\n    const cellB = new Cell();\n    cellB.bits.writeAddress(new Address(params.token1));\n\n    const sliceA = bytesToBase64(await cellA.toBoc(false));\n    const sliceB = bytesToBase64(await cellB.toBoc(false));\n\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_pool_address\",\n      [\n        [\"tvm.Slice\", sliceA],\n        [\"tvm.Slice\", sliceB],\n      ],\n    );\n\n    return parseAddress(result);\n  }\n\n  /**\n   * @param {Address | string} params.token0 - The address of the first Jetton minter\n   * @param {Address | string} params.token1 - The address of the second Jetton minter\n   *\n   * @returns {Pool} object for a pool with specified Jetton token addresses.\n   */\n  public async getPool(params: {\n    token0: AddressType;\n    token1: AddressType;\n  }) {\n    const jetton0 = new JettonMinter(\n      this.provider,\n      // @ts-expect-error - not all parameters are really required here\n      {\n        address: params.token0,\n      },\n    );\n\n    const jetton1 = new JettonMinter(\n      this.provider,\n      // @ts-expect-error - not all parameters are really required here\n      {\n        address: params.token1,\n      },\n    );\n\n    const contractAddress = await this.getAddress();\n\n    const [jetton0WalletAddress, jetton1WalletAddress] = await Promise.all([\n      this.stonApiClient.getJettonWalletAddress({\n        jettonAddress: (await jetton0.getAddress()).toString(),\n        ownerAddress: contractAddress.toString(),\n      }),\n      this.stonApiClient.getJettonWalletAddress({\n        jettonAddress: (await jetton1.getAddress()).toString(),\n        ownerAddress: contractAddress.toString(),\n      }),\n    ]);\n\n    const poolAddress = await this.getPoolAddress({\n      token0: jetton0WalletAddress,\n      token1: jetton1WalletAddress,\n    });\n\n    if (!poolAddress) return null;\n\n    return new PoolV1({\n      tonApiClient: this.provider,\n      stonApiClient: this.stonApiClient,\n      address: poolAddress,\n    });\n  }\n\n  /**\n   * @returns current state of the router.\n   */\n  public async getData() {\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_router_data\",\n      [],\n    );\n\n    return {\n      isLocked: parseBoolean(result[0]),\n      adminAddress: parseAddressNotNull(result[1] as Cell),\n      tempUpgrade: result[2] as Cell,\n      poolCode: result[3] as Cell,\n      jettonLpWalletCode: result[4] as Cell,\n      lpAccountCode: result[5] as Cell,\n    };\n  }\n}\n"],"names":["BN","bytesToBase64","Cell","Address","Contract","JettonMinter","TonWeb","_RouterV1","tonApiClient","stonApiClient","gasConstants","options","StonApiClient","params","payload","DEX_OP_CODES","contractAddress","offerJettonWalletAddress","askJettonWalletAddress","forwardPayload","forwardTonAmount","createJettonTransferMessage","gasAmount","proxyTonWalletAddress","jettonWalletAddress","routerWalletAddress","cellA","cellB","sliceA","sliceB","result","parseAddress","jetton0","jetton1","jetton0WalletAddress","jetton1WalletAddress","poolAddress","PoolV1","parseBoolean","parseAddressNotNull","DEX_VERSION","RouterV1"],"mappings":"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"}