import { type ContractOptions } from "tonweb";
import type { Cell, MessageData, AddressType, QueryIdType, AmountType, SdkContractOptions } from '../../../types';
import { LpAccountV1 } from "./LpAccountV1";
declare const Cell: typeof import("tonweb/dist/types/boc/cell").Cell, JettonMinter: typeof import("tonweb/dist/types/contract/token/ft/jetton-minter").JettonMinter;
export interface PoolV1Options extends SdkContractOptions, ContractOptions {
    address: Required<ContractOptions>["address"];
    gasConstants?: Partial<typeof PoolV1.gasConstants>;
}
/**
 * The pool is the contract that stores the AMM data for a certain pair and is responsible for handling “swaps” or providing liquidity for a certain pool.
 * For each pair (e.g. STON/USDT), there is only a single pool contract.
 * The pool is also a Jetton Minter, and handles minting/burning of Liquidity Provider Jettons.
 * All the swap/lp calculations are done in the pool contract.
 */
export declare class PoolV1 extends JettonMinter {
    static readonly version: "v1";
    static readonly gasConstants: {
        collectFees: import("bn.js");
        burn: import("bn.js");
    };
    protected readonly stonApiClient: import('../../../types').StonApiClient;
    readonly gasConstants: {
        collectFees: import("bn.js");
        burn: import("bn.js");
    };
    constructor({ tonApiClient, stonApiClient, gasConstants, ...options }: PoolV1Options);
    createCollectFeesBody(params?: {
        queryId?: QueryIdType;
    }): Promise<Cell>;
    /**
     * Build all data required to execute a `collect_fees` transaction.
     *
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} all data required to execute a `collect_fees` transaction.
     */
    buildCollectFeeTxParams(params?: {
        gasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    createBurnBody(params: {
        amount: AmountType;
        responseAddress: AddressType;
        queryId?: QueryIdType;
    }): Promise<Cell>;
    /**
     * Build all data required to execute a `burn` transaction.
     *
     * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)
     * @param {Address | string} params.responseAddress - Address of a user
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} all data required to execute a `burn` transaction.
     */
    buildBurnTxParams(params: {
        amount: AmountType;
        responseAddress: AddressType;
        gasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool
     *
     * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)
     * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)
     *
     * @returns {ExpectedOutputsData} structure with expected result of a token swap
     */
    getExpectedOutputs(params: {
        amount: AmountType;
        jettonWallet: AddressType;
    }): Promise<{
        jettonToReceive: import("bn.js");
        protocolFeePaid: import("bn.js");
        refFeePaid: import("bn.js");
    }>;
    /**
     * Estimate an expected amount of lp tokens minted when providing liquidity.
     *
     * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)
     * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)
     *
     * @returns {BN} an estimated amount of liquidity tokens to be minted
     */
    getExpectedTokens(params: {
        amount0: AmountType;
        amount1: AmountType;
    }): Promise<import("bn.js")>;
    /**
     * Estimate expected liquidity freed upon burning liquidity tokens.
     *
     * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)
     *
     * @returns {PoolAmountsData} structure with expected freed liquidity
     */
    getExpectedLiquidity(params: {
        jettonAmount: AmountType;
    }): Promise<{
        amount0: import("bn.js");
        amount1: import("bn.js");
    }>;
    /**
     * @param {Address | string} params.ownerAddress - Address of a user
     *
     * @returns the lp account address of a user
     */
    getLpAccountAddress(params: {
        ownerAddress: AddressType;
    }): Promise<import("tonweb/dist/types/utils/address").Address | null>;
    /**
     * @param {Address | string} params.ownerAddress - Address of a user
     *
     * @returns a JettonWallet object for an address returned by getJettonWalletAddress
     */
    getJettonWallet(params: {
        ownerAddress: AddressType;
    }): Promise<import("tonweb/dist/types/contract/token/ft/jetton-wallet").JettonWallet>;
    /**
     * @returns structure containing current state of the pool.
     */
    getData(): Promise<{
        reserve0: import("bn.js");
        reserve1: import("bn.js");
        token0WalletAddress: import("tonweb/dist/types/utils/address").Address;
        token1WalletAddress: import("tonweb/dist/types/utils/address").Address;
        lpFee: import("bn.js");
        protocolFee: import("bn.js");
        refFee: import("bn.js");
        protocolFeeAddress: import("tonweb/dist/types/utils/address").Address | null;
        collectedToken0ProtocolFee: import("bn.js");
        collectedToken1ProtocolFee: import("bn.js");
    }>;
    /**
     * @param {Address | string} params.ownerAddress - Address of a user
     *
     * @returns {LpAccount} object for address returned by getLpAccountAddress
     */
    getLpAccount(params: {
        ownerAddress: AddressType;
    }): Promise<LpAccountV1 | null>;
}
export {};
