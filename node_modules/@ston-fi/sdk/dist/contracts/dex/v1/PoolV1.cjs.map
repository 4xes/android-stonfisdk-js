{"version":3,"file":"PoolV1.cjs","sources":["../../../../src/contracts/dex/v1/PoolV1.ts"],"sourcesContent":["import TonWeb, { type ContractOptions } from \"tonweb\";\n\nimport type {\n  BN,\n  Cell,\n  MessageData,\n  AddressType,\n  QueryIdType,\n  AmountType,\n  SdkContractOptions,\n} from \"@/types\";\nimport { StonApiClient } from \"@/StonApiClient\";\nimport { parseAddress, parseAddressNotNull } from \"@/utils/parseAddress\";\n\nimport { DEX_VERSION, DEX_OP_CODES } from \"../constants\";\nimport { LpAccountV1 } from \"./LpAccountV1\";\n\nconst {\n  utils: { BN, bytesToBase64 },\n  boc: { Cell },\n  Address,\n  token: {\n    jetton: { JettonMinter, JettonWallet },\n  },\n} = TonWeb;\n\nexport interface PoolV1Options extends SdkContractOptions, ContractOptions {\n  address: Required<ContractOptions>[\"address\"];\n  gasConstants?: Partial<typeof PoolV1.gasConstants>;\n}\n\n/**\n * The pool is the contract that stores the AMM data for a certain pair and is responsible for handling “swaps” or providing liquidity for a certain pool.\n * For each pair (e.g. STON/USDT), there is only a single pool contract.\n * The pool is also a Jetton Minter, and handles minting/burning of Liquidity Provider Jettons.\n * All the swap/lp calculations are done in the pool contract.\n */\nexport class PoolV1 extends JettonMinter {\n  public static readonly version = DEX_VERSION.v1;\n  public static readonly gasConstants = {\n    collectFees: new BN(\"1100000000\"),\n    burn: new BN(\"500000000\"),\n  };\n\n  protected readonly stonApiClient;\n\n  public readonly gasConstants;\n\n  constructor({\n    tonApiClient,\n    stonApiClient,\n    gasConstants,\n    ...options\n  }: PoolV1Options) {\n    super(\n      tonApiClient,\n      // @ts-expect-error - not all parameters are really required here\n      options,\n    );\n\n    this.stonApiClient = stonApiClient ?? new StonApiClient(tonApiClient);\n    this.gasConstants = {\n      ...PoolV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createCollectFeesBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.COLLECT_FEES, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  }\n\n  /**\n   * Build all data required to execute a `collect_fees` transaction.\n   *\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `collect_fees` transaction.\n   */\n  public async buildCollectFeeTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createCollectFeesBody({\n      queryId: params?.queryId,\n    });\n\n    const gasAmount = new BN(\n      params?.gasAmount ?? this.gasConstants.collectFees,\n    );\n\n    return {\n      to: new Address(to.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  public async createBurnBody(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.REQUEST_BURN, 32);\n    message.bits.writeUint(params.queryId ?? 0, 64);\n    message.bits.writeCoins(new BN(params.amount));\n    message.bits.writeAddress(new Address(params.responseAddress));\n\n    return message;\n  }\n\n  /**\n   * Build all data required to execute a `burn` transaction.\n   *\n   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)\n   * @param {Address | string} params.responseAddress - Address of a user\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `burn` transaction.\n   */\n  public async buildBurnTxParams(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [to, payload] = await Promise.all([\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: contractAddress.toString(),\n            ownerAddress: params.responseAddress.toString(),\n          }),\n        ))(),\n      this.createBurnBody({\n        amount: params.amount,\n        responseAddress: params.responseAddress,\n        queryId: params.queryId,\n      }),\n    ]);\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.burn);\n\n    return {\n      to: new Address(to.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool\n   *\n   * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)\n   * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)\n   *\n   * @returns {ExpectedOutputsData} structure with expected result of a token swap\n   */\n  public async getExpectedOutputs(params: {\n    amount: AmountType;\n    jettonWallet: AddressType;\n  }) {\n    const cell = new Cell();\n\n    cell.bits.writeAddress(new Address(params.jettonWallet));\n\n    const slice = bytesToBase64(await cell.toBoc(false));\n\n    const poolAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      poolAddress.toString(),\n      \"get_expected_outputs\",\n      [\n        [\"int\", params.amount.toString()],\n        [\"tvm.Slice\", slice],\n      ],\n    );\n\n    return {\n      jettonToReceive: result[0] as BN,\n      protocolFeePaid: result[1] as BN,\n      refFeePaid: result[2] as BN,\n    };\n  }\n\n  /**\n   * Estimate an expected amount of lp tokens minted when providing liquidity.\n   *\n   * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)\n   *\n   * @returns {BN} an estimated amount of liquidity tokens to be minted\n   */\n  public async getExpectedTokens(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n  }) {\n    const poolAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      poolAddress.toString(),\n      \"get_expected_tokens\",\n      [\n        [\"int\", params.amount0.toString()],\n        [\"int\", params.amount1.toString()],\n      ],\n    );\n\n    return result as BN;\n  }\n\n  /**\n   * Estimate expected liquidity freed upon burning liquidity tokens.\n   *\n   * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)\n   *\n   * @returns {PoolAmountsData} structure with expected freed liquidity\n   */\n  public async getExpectedLiquidity(params: {\n    jettonAmount: AmountType;\n  }) {\n    const poolAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      poolAddress.toString(),\n      \"get_expected_liquidity\",\n      [[\"int\", params.jettonAmount.toString()]],\n    );\n\n    return {\n      amount0: result[0] as BN,\n      amount1: result[1] as BN,\n    };\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns the lp account address of a user\n   */\n  public async getLpAccountAddress(params: {\n    ownerAddress: AddressType;\n  }) {\n    const cell = new Cell();\n\n    cell.bits.writeAddress(new Address(params.ownerAddress));\n\n    const slice = bytesToBase64(await cell.toBoc(false));\n\n    const poolAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      poolAddress.toString(),\n      \"get_lp_account_address\",\n      [[\"tvm.Slice\", slice]],\n    );\n\n    return parseAddress(result);\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns a JettonWallet object for an address returned by getJettonWalletAddress\n   */\n  public async getJettonWallet(params: { ownerAddress: AddressType }) {\n    const poolWalletAddress = await this.stonApiClient.getJettonWalletAddress({\n      jettonAddress: (await this.getAddress()).toString(),\n      ownerAddress: params.ownerAddress.toString(),\n    });\n\n    return new JettonWallet(this.provider, { address: poolWalletAddress });\n  }\n\n  /**\n   * @returns structure containing current state of the pool.\n   */\n  public async getData() {\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_pool_data\",\n    );\n\n    return {\n      reserve0: result[0] as BN,\n      reserve1: result[1] as BN,\n      token0WalletAddress: parseAddressNotNull(result[2] as Cell),\n      token1WalletAddress: parseAddressNotNull(result[3] as Cell),\n      lpFee: result[4] as BN,\n      protocolFee: result[5] as BN,\n      refFee: result[6] as BN,\n      protocolFeeAddress: parseAddress(result[7]),\n      collectedToken0ProtocolFee: result[8] as BN,\n      collectedToken1ProtocolFee: result[9] as BN,\n    };\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {LpAccount} object for address returned by getLpAccountAddress\n   */\n  public async getLpAccount(params: {\n    ownerAddress: AddressType;\n  }) {\n    const accountAddress = await this.getLpAccountAddress(params);\n\n    if (!accountAddress) return null;\n\n    return new LpAccountV1({\n      tonApiClient: this.provider,\n      stonApiClient: this.stonApiClient,\n      address: accountAddress,\n    });\n  }\n}\n"],"names":["BN","bytesToBase64","Cell","Address","JettonMinter","JettonWallet","TonWeb","_PoolV1","tonApiClient","stonApiClient","gasConstants","options","StonApiClient","params","message","DEX_OP_CODES","to","payload","gasAmount","contractAddress","cell","slice","poolAddress","result","parseAddress","poolWalletAddress","parseAddressNotNull","accountAddress","LpAccountV1","DEX_VERSION","PoolV1"],"mappings":"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"}