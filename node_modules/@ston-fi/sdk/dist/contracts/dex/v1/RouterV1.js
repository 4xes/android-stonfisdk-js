import T from "tonweb";
import { StonApiClient as m } from "../../../StonApiClient.js";
import { createJettonTransferMessage as l } from "../../../utils/createJettonTransferMessage.js";
import { parseAddress as h, parseAddressNotNull as J } from "../../../utils/parseAddress.js";
import { parseBoolean as S } from "../../../utils/parseBoolean.js";
import { DEX_VERSION as p, DEX_OP_CODES as g } from "../constants.js";
import { PoolV1 as W } from "./PoolV1.js";
const {
  utils: { BN: o, bytesToBase64: y },
  boc: { Cell: w },
  Address: s,
  Contract: C,
  token: {
    jetton: { JettonMinter: f }
  }
} = T, u = class c extends C {
  constructor({
    tonApiClient: t,
    stonApiClient: e,
    gasConstants: r,
    ...n
  }) {
    super(t, {
      ...n,
      address: n.address ?? c.address
    }), this.stonApiClient = e ?? new m(t), this.gasConstants = {
      ...c.gasConstants,
      ...r
    };
  }
  async createSwapBody(t) {
    const e = new w();
    return e.bits.writeUint(g.SWAP, 32), e.bits.writeAddress(new s(t.askJettonWalletAddress)), e.bits.writeCoins(new o(t.minAskAmount)), e.bits.writeAddress(new s(t.userWalletAddress)), t.referralAddress ? (e.bits.writeUint(1, 1), e.bits.writeAddress(new s(t.referralAddress))) : e.bits.writeUint(0, 1), e;
  }
  /**
   * Build all data required to execute a jetton to jetton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a jetton `swap` transaction
   */
  async buildSwapJettonToJettonTxParams(t) {
    const e = await this.getAddress(), [r, n] = await Promise.all([
      (async () => new s(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.offerJettonAddress.toString(),
          ownerAddress: t.userWalletAddress.toString()
        })
      ))(),
      (async () => new s(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.askJettonAddress.toString(),
          ownerAddress: e.toString()
        })
      ))()
    ]), a = await this.createSwapBody({
      userWalletAddress: t.userWalletAddress,
      minAskAmount: t.minAskAmount,
      askJettonWalletAddress: n,
      referralAddress: t.referralAddress
    }), d = new o(
      t.forwardGasAmount ?? this.gasConstants.swapJettonToJetton.forwardGasAmount
    ), i = l({
      queryId: t.queryId ?? 0,
      amount: t.offerAmount,
      destination: e,
      responseDestination: t.userWalletAddress,
      forwardTonAmount: d,
      forwardPayload: a
    }), A = new o(
      t.gasAmount ?? this.gasConstants.swapJettonToJetton.gasAmount
    );
    return {
      to: new s(r.toString(!0, !0, !0)),
      payload: i,
      gasAmount: A
    };
  }
  /**
   * Build all data required to execute a jetton to ton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a jetton `swap` transaction
   */
  async buildSwapJettonToTonTxParams(t) {
    return await this.buildSwapJettonToJettonTxParams({
      ...t,
      askJettonAddress: t.proxyTonAddress,
      gasAmount: t.gasAmount ?? this.gasConstants.swapJettonToTon.gasAmount,
      forwardGasAmount: t.forwardGasAmount ?? this.gasConstants.swapJettonToTon.forwardGasAmount
    });
  }
  /**
   * Build all data required to execute a ton to jetton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
   * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {Address | string | undefined} params.referralAddress - Optional; Referral address
   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a ton to jetton `swap` transaction
   */
  async buildSwapTonToJettonTxParams(t) {
    const e = await this.getAddress(), [r, n] = await Promise.all([
      (async () => new s(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.proxyTonAddress.toString(),
          ownerAddress: e.toString()
        })
      ))(),
      (async () => new s(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.askJettonAddress.toString(),
          ownerAddress: e.toString()
        })
      ))()
    ]), a = await this.createSwapBody({
      userWalletAddress: t.userWalletAddress,
      minAskAmount: t.minAskAmount,
      askJettonWalletAddress: n,
      referralAddress: t.referralAddress
    }), d = new o(
      t.forwardGasAmount ?? this.gasConstants.swapTonToJetton.forwardGasAmount
    ), i = l({
      queryId: t.queryId ?? 0,
      amount: t.offerAmount,
      destination: e,
      forwardTonAmount: d,
      forwardPayload: a
    }), A = new o(t.offerAmount).add(d);
    return {
      to: new s(r.toString(!0, !0, !0)),
      payload: i,
      gasAmount: A
    };
  }
  async createProvideLiquidityBody(t) {
    const e = new w();
    return e.bits.writeUint(g.PROVIDE_LIQUIDITY, 32), e.bits.writeAddress(new s(t.routerWalletAddress)), e.bits.writeCoins(new o(t.minLpOut)), e;
  }
  /**
   * Collect all data required to execute a jetton `provide_lp` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token
   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
   * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)
   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a jetton `provide_lp` transaction
   */
  async buildProvideLiquidityJettonTxParams(t) {
    const e = await this.getAddress(), [r, n] = await Promise.all([
      (async () => new s(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.sendTokenAddress.toString(),
          ownerAddress: t.userWalletAddress.toString()
        })
      ))(),
      (async () => new s(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.otherTokenAddress.toString(),
          ownerAddress: e.toString()
        })
      ))()
    ]), a = await this.createProvideLiquidityBody({
      routerWalletAddress: n,
      minLpOut: t.minLpOut
    }), d = new o(
      t.forwardGasAmount ?? this.gasConstants.provideLpJetton.forwardGasAmount
    ), i = l({
      queryId: t.queryId ?? 0,
      amount: t.sendAmount,
      destination: e,
      responseDestination: t.userWalletAddress,
      forwardTonAmount: d,
      forwardPayload: a
    }), A = new o(
      t.gasAmount ?? this.gasConstants.provideLpJetton.gasAmount
    );
    return {
      to: new s(r.toString(!0, !0, !0)),
      payload: i,
      gasAmount: A
    };
  }
  /**
   * Collect all data required to execute a proxy ton `provide_lp` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
   * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)
   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction
   */
  async buildProvideLiquidityTonTxParams(t) {
    const e = await this.getAddress(), [r, n] = await Promise.all([
      (async () => new s(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.proxyTonAddress.toString(),
          ownerAddress: e.toString()
        })
      ))(),
      (async () => new s(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.otherTokenAddress.toString(),
          ownerAddress: e.toString()
        })
      ))()
    ]), a = await this.createProvideLiquidityBody({
      routerWalletAddress: n,
      minLpOut: t.minLpOut
    }), d = new o(
      t.forwardGasAmount ?? this.gasConstants.provideLpTon.forwardGasAmount
    ), i = l({
      queryId: t.queryId ?? 0,
      amount: t.sendAmount,
      destination: e,
      forwardTonAmount: d,
      forwardPayload: a
    }), A = new o(t.sendAmount).add(d);
    return {
      to: new s(r.toString(!0, !0, !0)),
      payload: i,
      gasAmount: A
    };
  }
  /**
   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.
   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.
   *
   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton
   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton
   *
   * @returns {Address | null} an address of a pool for a specified pair of assets.
   */
  async getPoolAddress(t) {
    const e = new w();
    e.bits.writeAddress(new s(t.token0));
    const r = new w();
    r.bits.writeAddress(new s(t.token1));
    const n = y(await e.toBoc(!1)), a = y(await r.toBoc(!1)), d = await this.getAddress(), i = await this.provider.call2(
      d.toString(),
      "get_pool_address",
      [
        ["tvm.Slice", n],
        ["tvm.Slice", a]
      ]
    );
    return h(i);
  }
  /**
   * @param {Address | string} params.token0 - The address of the first Jetton minter
   * @param {Address | string} params.token1 - The address of the second Jetton minter
   *
   * @returns {Pool} object for a pool with specified Jetton token addresses.
   */
  async getPool(t) {
    const e = new f(
      this.provider,
      // @ts-expect-error - not all parameters are really required here
      {
        address: t.token0
      }
    ), r = new f(
      this.provider,
      // @ts-expect-error - not all parameters are really required here
      {
        address: t.token1
      }
    ), n = await this.getAddress(), [a, d] = await Promise.all([
      this.stonApiClient.getJettonWalletAddress({
        jettonAddress: (await e.getAddress()).toString(),
        ownerAddress: n.toString()
      }),
      this.stonApiClient.getJettonWalletAddress({
        jettonAddress: (await r.getAddress()).toString(),
        ownerAddress: n.toString()
      })
    ]), i = await this.getPoolAddress({
      token0: a,
      token1: d
    });
    return i ? new W({
      tonApiClient: this.provider,
      stonApiClient: this.stonApiClient,
      address: i
    }) : null;
  }
  /**
   * @returns current state of the router.
   */
  async getData() {
    const t = await this.getAddress(), e = await this.provider.call2(
      t.toString(),
      "get_router_data",
      []
    );
    return {
      isLocked: S(e[0]),
      adminAddress: J(e[1]),
      tempUpgrade: e[2],
      poolCode: e[3],
      jettonLpWalletCode: e[4],
      lpAccountCode: e[5]
    };
  }
};
u.version = p.v1;
u.address = new s(
  "EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt"
);
u.gasConstants = {
  swapJettonToJetton: {
    gasAmount: new o("265000000"),
    forwardGasAmount: new o("205000000")
  },
  swapJettonToTon: {
    gasAmount: new o("185000000"),
    forwardGasAmount: new o("125000000")
  },
  swapTonToJetton: {
    forwardGasAmount: new o("215000000")
  },
  provideLpJetton: {
    gasAmount: new o("300000000"),
    forwardGasAmount: new o("240000000")
  },
  provideLpTon: {
    forwardGasAmount: new o("260000000")
  }
};
let B = u;
export {
  B as RouterV1
};
//# sourceMappingURL=RouterV1.js.map
