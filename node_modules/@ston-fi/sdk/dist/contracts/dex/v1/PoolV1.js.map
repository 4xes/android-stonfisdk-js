{"version":3,"file":"PoolV1.js","sources":["../../../../src/contracts/dex/v1/PoolV1.ts"],"sourcesContent":["import TonWeb, { type ContractOptions } from \"tonweb\";\n\nimport type {\n  BN,\n  Cell,\n  MessageData,\n  AddressType,\n  QueryIdType,\n  AmountType,\n  SdkContractOptions,\n} from \"@/types\";\nimport { StonApiClient } from \"@/StonApiClient\";\nimport { parseAddress, parseAddressNotNull } from \"@/utils/parseAddress\";\n\nimport { DEX_VERSION, DEX_OP_CODES } from \"../constants\";\nimport { LpAccountV1 } from \"./LpAccountV1\";\n\nconst {\n  utils: { BN, bytesToBase64 },\n  boc: { Cell },\n  Address,\n  token: {\n    jetton: { JettonMinter, JettonWallet },\n  },\n} = TonWeb;\n\nexport interface PoolV1Options extends SdkContractOptions, ContractOptions {\n  address: Required<ContractOptions>[\"address\"];\n  gasConstants?: Partial<typeof PoolV1.gasConstants>;\n}\n\n/**\n * The pool is the contract that stores the AMM data for a certain pair and is responsible for handling “swaps” or providing liquidity for a certain pool.\n * For each pair (e.g. STON/USDT), there is only a single pool contract.\n * The pool is also a Jetton Minter, and handles minting/burning of Liquidity Provider Jettons.\n * All the swap/lp calculations are done in the pool contract.\n */\nexport class PoolV1 extends JettonMinter {\n  public static readonly version = DEX_VERSION.v1;\n  public static readonly gasConstants = {\n    collectFees: new BN(\"1100000000\"),\n    burn: new BN(\"500000000\"),\n  };\n\n  protected readonly stonApiClient;\n\n  public readonly gasConstants;\n\n  constructor({\n    tonApiClient,\n    stonApiClient,\n    gasConstants,\n    ...options\n  }: PoolV1Options) {\n    super(\n      tonApiClient,\n      // @ts-expect-error - not all parameters are really required here\n      options,\n    );\n\n    this.stonApiClient = stonApiClient ?? new StonApiClient(tonApiClient);\n    this.gasConstants = {\n      ...PoolV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createCollectFeesBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.COLLECT_FEES, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  }\n\n  /**\n   * Build all data required to execute a `collect_fees` transaction.\n   *\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `collect_fees` transaction.\n   */\n  public async buildCollectFeeTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createCollectFeesBody({\n      queryId: params?.queryId,\n    });\n\n    const gasAmount = new BN(\n      params?.gasAmount ?? this.gasConstants.collectFees,\n    );\n\n    return {\n      to: new Address(to.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  public async createBurnBody(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.REQUEST_BURN, 32);\n    message.bits.writeUint(params.queryId ?? 0, 64);\n    message.bits.writeCoins(new BN(params.amount));\n    message.bits.writeAddress(new Address(params.responseAddress));\n\n    return message;\n  }\n\n  /**\n   * Build all data required to execute a `burn` transaction.\n   *\n   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)\n   * @param {Address | string} params.responseAddress - Address of a user\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `burn` transaction.\n   */\n  public async buildBurnTxParams(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [to, payload] = await Promise.all([\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: contractAddress.toString(),\n            ownerAddress: params.responseAddress.toString(),\n          }),\n        ))(),\n      this.createBurnBody({\n        amount: params.amount,\n        responseAddress: params.responseAddress,\n        queryId: params.queryId,\n      }),\n    ]);\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.burn);\n\n    return {\n      to: new Address(to.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool\n   *\n   * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)\n   * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)\n   *\n   * @returns {ExpectedOutputsData} structure with expected result of a token swap\n   */\n  public async getExpectedOutputs(params: {\n    amount: AmountType;\n    jettonWallet: AddressType;\n  }) {\n    const cell = new Cell();\n\n    cell.bits.writeAddress(new Address(params.jettonWallet));\n\n    const slice = bytesToBase64(await cell.toBoc(false));\n\n    const poolAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      poolAddress.toString(),\n      \"get_expected_outputs\",\n      [\n        [\"int\", params.amount.toString()],\n        [\"tvm.Slice\", slice],\n      ],\n    );\n\n    return {\n      jettonToReceive: result[0] as BN,\n      protocolFeePaid: result[1] as BN,\n      refFeePaid: result[2] as BN,\n    };\n  }\n\n  /**\n   * Estimate an expected amount of lp tokens minted when providing liquidity.\n   *\n   * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)\n   *\n   * @returns {BN} an estimated amount of liquidity tokens to be minted\n   */\n  public async getExpectedTokens(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n  }) {\n    const poolAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      poolAddress.toString(),\n      \"get_expected_tokens\",\n      [\n        [\"int\", params.amount0.toString()],\n        [\"int\", params.amount1.toString()],\n      ],\n    );\n\n    return result as BN;\n  }\n\n  /**\n   * Estimate expected liquidity freed upon burning liquidity tokens.\n   *\n   * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)\n   *\n   * @returns {PoolAmountsData} structure with expected freed liquidity\n   */\n  public async getExpectedLiquidity(params: {\n    jettonAmount: AmountType;\n  }) {\n    const poolAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      poolAddress.toString(),\n      \"get_expected_liquidity\",\n      [[\"int\", params.jettonAmount.toString()]],\n    );\n\n    return {\n      amount0: result[0] as BN,\n      amount1: result[1] as BN,\n    };\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns the lp account address of a user\n   */\n  public async getLpAccountAddress(params: {\n    ownerAddress: AddressType;\n  }) {\n    const cell = new Cell();\n\n    cell.bits.writeAddress(new Address(params.ownerAddress));\n\n    const slice = bytesToBase64(await cell.toBoc(false));\n\n    const poolAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      poolAddress.toString(),\n      \"get_lp_account_address\",\n      [[\"tvm.Slice\", slice]],\n    );\n\n    return parseAddress(result);\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns a JettonWallet object for an address returned by getJettonWalletAddress\n   */\n  public async getJettonWallet(params: { ownerAddress: AddressType }) {\n    const poolWalletAddress = await this.stonApiClient.getJettonWalletAddress({\n      jettonAddress: (await this.getAddress()).toString(),\n      ownerAddress: params.ownerAddress.toString(),\n    });\n\n    return new JettonWallet(this.provider, { address: poolWalletAddress });\n  }\n\n  /**\n   * @returns structure containing current state of the pool.\n   */\n  public async getData() {\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_pool_data\",\n    );\n\n    return {\n      reserve0: result[0] as BN,\n      reserve1: result[1] as BN,\n      token0WalletAddress: parseAddressNotNull(result[2] as Cell),\n      token1WalletAddress: parseAddressNotNull(result[3] as Cell),\n      lpFee: result[4] as BN,\n      protocolFee: result[5] as BN,\n      refFee: result[6] as BN,\n      protocolFeeAddress: parseAddress(result[7]),\n      collectedToken0ProtocolFee: result[8] as BN,\n      collectedToken1ProtocolFee: result[9] as BN,\n    };\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {LpAccount} object for address returned by getLpAccountAddress\n   */\n  public async getLpAccount(params: {\n    ownerAddress: AddressType;\n  }) {\n    const accountAddress = await this.getLpAccountAddress(params);\n\n    if (!accountAddress) return null;\n\n    return new LpAccountV1({\n      tonApiClient: this.provider,\n      stonApiClient: this.stonApiClient,\n      address: accountAddress,\n    });\n  }\n}\n"],"names":["BN","bytesToBase64","Cell","Address","JettonMinter","JettonWallet","TonWeb","_PoolV1","tonApiClient","stonApiClient","gasConstants","options","StonApiClient","params","message","DEX_OP_CODES","to","payload","gasAmount","contractAddress","cell","slice","poolAddress","result","parseAddress","poolWalletAddress","parseAddressNotNull","accountAddress","LpAccountV1","DEX_VERSION","PoolV1"],"mappings":"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"}