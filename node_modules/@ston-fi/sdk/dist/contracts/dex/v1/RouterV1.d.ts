import { type ContractOptions } from "tonweb";
import type { Cell, MessageData, AddressType, QueryIdType, AmountType, SdkContractOptions } from '../../../types';
import { PoolV1 } from "./PoolV1";
declare const Cell: typeof import("tonweb/dist/types/boc/cell").Cell, Contract: typeof import("tonweb/dist/types/contract/contract").Contract;
export interface RouterV1Options extends SdkContractOptions, ContractOptions {
    gasConstants?: Partial<typeof RouterV1.gasConstants>;
}
/**
 * The router is the contract that acts as an entrypoint for all DEX calls.
 * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.
 * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,
 * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.
 * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.
 */
export declare class RouterV1 extends Contract {
    static readonly version: "v1";
    static readonly address: import("tonweb/dist/types/utils/address").Address;
    static readonly gasConstants: {
        swapJettonToJetton: {
            gasAmount: import("bn.js");
            forwardGasAmount: import("bn.js");
        };
        swapJettonToTon: {
            gasAmount: import("bn.js");
            forwardGasAmount: import("bn.js");
        };
        swapTonToJetton: {
            forwardGasAmount: import("bn.js");
        };
        provideLpJetton: {
            gasAmount: import("bn.js");
            forwardGasAmount: import("bn.js");
        };
        provideLpTon: {
            forwardGasAmount: import("bn.js");
        };
    };
    protected readonly stonApiClient: import('../../../types').StonApiClient;
    readonly gasConstants: {
        swapJettonToJetton: {
            gasAmount: import("bn.js");
            forwardGasAmount: import("bn.js");
        };
        swapJettonToTon: {
            gasAmount: import("bn.js");
            forwardGasAmount: import("bn.js");
        };
        swapTonToJetton: {
            forwardGasAmount: import("bn.js");
        };
        provideLpJetton: {
            gasAmount: import("bn.js");
            forwardGasAmount: import("bn.js");
        };
        provideLpTon: {
            forwardGasAmount: import("bn.js");
        };
    };
    constructor({ tonApiClient, stonApiClient, gasConstants, ...options }: RouterV1Options);
    createSwapBody(params: {
        userWalletAddress: AddressType;
        minAskAmount: AmountType;
        askJettonWalletAddress: AddressType;
        referralAddress?: AddressType;
    }): Promise<Cell>;
    /**
     * Build all data required to execute a jetton to jetton `swap` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
     * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
     * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
     * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
     * @param {Address | string | undefined} params.referralAddress - Optional; referral address
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a jetton `swap` transaction
     */
    buildSwapJettonToJettonTxParams(params: {
        userWalletAddress: AddressType;
        offerJettonAddress: AddressType;
        askJettonAddress: AddressType;
        offerAmount: AmountType;
        minAskAmount: AmountType;
        referralAddress?: AddressType;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * Build all data required to execute a jetton to ton `swap` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
     * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
     * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
     * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
     * @param {Address | string | undefined} params.referralAddress - Optional; referral address
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a jetton `swap` transaction
     */
    buildSwapJettonToTonTxParams(params: {
        userWalletAddress: AddressType;
        offerJettonAddress: AddressType;
        proxyTonAddress: AddressType;
        offerAmount: AmountType;
        minAskAmount: AmountType;
        referralAddress?: AddressType;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * Build all data required to execute a ton to jetton `swap` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
     * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
     * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)
     * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
     * @param {Address | string | undefined} params.referralAddress - Optional; Referral address
     * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a ton to jetton `swap` transaction
     */
    buildSwapTonToJettonTxParams(params: {
        userWalletAddress: AddressType;
        proxyTonAddress: AddressType;
        askJettonAddress: AddressType;
        offerAmount: AmountType;
        minAskAmount: AmountType;
        referralAddress?: AddressType | undefined;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    createProvideLiquidityBody(params: {
        routerWalletAddress: AddressType;
        minLpOut: AmountType;
    }): Promise<Cell>;
    /**
     * Collect all data required to execute a jetton `provide_lp` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token
     * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
     * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)
     * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a jetton `provide_lp` transaction
     */
    buildProvideLiquidityJettonTxParams(params: {
        userWalletAddress: AddressType;
        sendTokenAddress: AddressType;
        otherTokenAddress: AddressType;
        sendAmount: AmountType;
        minLpOut: AmountType;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * Collect all data required to execute a proxy ton `provide_lp` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
     * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
     * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)
     * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
     * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction
     */
    buildProvideLiquidityTonTxParams(params: {
        userWalletAddress: AddressType;
        proxyTonAddress: AddressType;
        otherTokenAddress: AddressType;
        sendAmount: AmountType;
        minLpOut: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.
     * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.
     *
     * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton
     * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton
     *
     * @returns {Address | null} an address of a pool for a specified pair of assets.
     */
    getPoolAddress(params: {
        token0: AddressType;
        token1: AddressType;
    }): Promise<import("tonweb/dist/types/utils/address").Address | null>;
    /**
     * @param {Address | string} params.token0 - The address of the first Jetton minter
     * @param {Address | string} params.token1 - The address of the second Jetton minter
     *
     * @returns {Pool} object for a pool with specified Jetton token addresses.
     */
    getPool(params: {
        token0: AddressType;
        token1: AddressType;
    }): Promise<PoolV1 | null>;
    /**
     * @returns current state of the router.
     */
    getData(): Promise<{
        isLocked: boolean;
        adminAddress: import("tonweb/dist/types/utils/address").Address;
        tempUpgrade: import("tonweb/dist/types/boc/cell").Cell;
        poolCode: import("tonweb/dist/types/boc/cell").Cell;
        jettonLpWalletCode: import("tonweb/dist/types/boc/cell").Cell;
        lpAccountCode: import("tonweb/dist/types/boc/cell").Cell;
    }>;
}
export {};
