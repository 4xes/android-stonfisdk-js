import y from "tonweb";
import { StonApiClient as A } from "../../../StonApiClient.js";
import { parseAddressNotNull as c } from "../../../utils/parseAddress.js";
import { DEX_VERSION as g, DEX_OP_CODES as o } from "../constants.js";
const {
  utils: { BN: n },
  boc: { Cell: u },
  Contract: a,
  Address: d
} = y, r = class w extends a {
  constructor({
    tonApiClient: t,
    stonApiClient: e,
    gasConstants: i,
    ...s
  }) {
    super(t, s), this.stonApiClient = e ?? new A(t), this.gasConstants = {
      ...w.gasConstants,
      ...i
    };
  }
  async createRefundBody(t) {
    const e = new u();
    return e.bits.writeUint(o.REFUND, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
  }
  /**
   * Build all data required to execute a `refund_me` transaction.
   *
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `refund_me` transaction.
   */
  async buildRefundTxParams(t) {
    const e = await this.getAddress(), i = await this.createRefundBody({ queryId: t == null ? void 0 : t.queryId }), s = new n((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.refund);
    return {
      to: new d(e.toString(!0, !0, !0)),
      payload: i,
      gasAmount: s
    };
  }
  async createDirectAddLiquidityBody(t) {
    const e = new u();
    return e.bits.writeUint(o.DIRECT_ADD_LIQUIDITY, 32), e.bits.writeUint(t.queryId ?? 0, 64), e.bits.writeCoins(new n(t.amount0)), e.bits.writeCoins(new n(t.amount1)), e.bits.writeCoins(new n(t.minimumLpToMint ?? 1)), e;
  }
  /**
   * Build all data required to execute a `direct_add_liquidity` transaction.
   *
   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)
   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)
   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `direct_add_liquidity` transaction.
   */
  async buildDirectAddLiquidityTxParams(t) {
    const e = await this.getAddress(), i = await this.createDirectAddLiquidityBody({
      amount0: t.amount0,
      amount1: t.amount1,
      minimumLpToMint: t.minimumLpToMint,
      queryId: t.queryId
    }), s = new n(t.gasAmount ?? this.gasConstants.directAddLp);
    return {
      to: new d(e.toString(!0, !0, !0)),
      payload: i,
      gasAmount: s
    };
  }
  async createResetGasBody(t) {
    const e = new u();
    return e.bits.writeUint(o.RESET_GAS, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
  }
  /**
   * Build all data required to execute a `reset_gas` transaction.
   *
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `reset_gas` transaction.
   */
  async buildResetGasTxParams(t) {
    const e = await this.getAddress(), i = await this.createResetGasBody({ queryId: t == null ? void 0 : t.queryId }), s = new n((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.resetGas);
    return {
      to: new d(e.toString(!0, !0, !0)),
      payload: i,
      gasAmount: s
    };
  }
  /**
   * @returns structure containing current state of the lp account.
   */
  async getData() {
    const t = await this.getAddress(), e = await this.provider.call2(
      t.toString(),
      "get_lp_account_data"
    );
    return {
      userAddress: c(e[0]),
      poolAddress: c(e[1]),
      amount0: e[2],
      amount1: e[3]
    };
  }
};
r.version = g.v1;
r.gasConstants = {
  refund: new n("300000000"),
  directAddLp: new n("300000000"),
  resetGas: new n("300000000")
};
let h = r;
export {
  h as LpAccountV1
};
//# sourceMappingURL=LpAccountV1.js.map
