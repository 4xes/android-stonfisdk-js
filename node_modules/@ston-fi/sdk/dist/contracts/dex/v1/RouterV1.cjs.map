{"version":3,"file":"RouterV1.cjs","sources":["../../../../src/contracts/dex/v1/RouterV1.ts"],"sourcesContent":["import TonWeb, { type ContractOptions } from \"tonweb\";\n\nimport type {\n  BN,\n  Cell,\n  MessageData,\n  AddressType,\n  QueryIdType,\n  AmountType,\n  SdkContractOptions,\n} from \"@/types\";\nimport { StonApiClient } from \"@/StonApiClient\";\nimport { createJettonTransferMessage } from \"@/utils/createJettonTransferMessage\";\nimport { parseAddress, parseAddressNotNull } from \"@/utils/parseAddress\";\nimport { parseBoolean } from \"@/utils/parseBoolean\";\n\nimport { DEX_VERSION, DEX_OP_CODES } from \"../constants\";\n\nimport { PoolV1 } from \"./PoolV1\";\n\nconst {\n  utils: { BN, bytesToBase64 },\n  boc: { Cell },\n  Address,\n  Contract,\n  token: {\n    jetton: { JettonMinter },\n  },\n} = TonWeb;\n\nexport interface RouterV1Options extends SdkContractOptions, ContractOptions {\n  gasConstants?: Partial<typeof RouterV1.gasConstants>;\n}\n\n/**\n * The router is the contract that acts as an entrypoint for all DEX calls.\n * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.\n * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,\n * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.\n * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.\n */\nexport class RouterV1 extends Contract {\n  public static readonly version = DEX_VERSION.v1;\n  public static readonly address = new Address(\n    \"EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt\",\n  );\n  public static readonly gasConstants = {\n    swapJettonToJetton: {\n      gasAmount: new BN(\"265000000\"),\n      forwardGasAmount: new BN(\"205000000\"),\n    },\n    swapJettonToTon: {\n      gasAmount: new BN(\"185000000\"),\n      forwardGasAmount: new BN(\"125000000\"),\n    },\n    swapTonToJetton: {\n      forwardGasAmount: new BN(\"215000000\"),\n    },\n    provideLpJetton: {\n      gasAmount: new BN(\"300000000\"),\n      forwardGasAmount: new BN(\"240000000\"),\n    },\n    provideLpTon: {\n      forwardGasAmount: new BN(\"260000000\"),\n    },\n  };\n\n  protected readonly stonApiClient;\n\n  public readonly gasConstants;\n\n  constructor({\n    tonApiClient,\n    stonApiClient,\n    gasConstants,\n    ...options\n  }: RouterV1Options) {\n    super(tonApiClient, {\n      ...options,\n      address: options.address ?? RouterV1.address,\n    });\n\n    this.stonApiClient = stonApiClient ?? new StonApiClient(tonApiClient);\n    this.gasConstants = {\n      ...RouterV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createSwapBody(params: {\n    userWalletAddress: AddressType;\n    minAskAmount: AmountType;\n    askJettonWalletAddress: AddressType;\n    referralAddress?: AddressType;\n  }): Promise<Cell> {\n    const payload = new Cell();\n\n    payload.bits.writeUint(DEX_OP_CODES.SWAP, 32);\n    payload.bits.writeAddress(new Address(params.askJettonWalletAddress));\n    payload.bits.writeCoins(new BN(params.minAskAmount));\n    payload.bits.writeAddress(new Address(params.userWalletAddress));\n\n    if (params.referralAddress) {\n      payload.bits.writeUint(1, 1);\n      payload.bits.writeAddress(new Address(params.referralAddress));\n    } else {\n      payload.bits.writeUint(0, 1);\n    }\n\n    return payload;\n  }\n\n  /**\n   * Build all data required to execute a jetton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `swap` transaction\n   */\n  public async buildSwapJettonToJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    offerJettonAddress: AddressType;\n    askJettonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    referralAddress?: AddressType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [offerJettonWalletAddress, askJettonWalletAddress] =\n      await Promise.all([\n        (async () =>\n          new Address(\n            await this.stonApiClient.getJettonWalletAddress({\n              jettonAddress: params.offerJettonAddress.toString(),\n              ownerAddress: params.userWalletAddress.toString(),\n            }),\n          ))(),\n        (async () =>\n          new Address(\n            await this.stonApiClient.getJettonWalletAddress({\n              jettonAddress: params.askJettonAddress.toString(),\n              ownerAddress: contractAddress.toString(),\n            }),\n          ))(),\n      ]);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ??\n        this.gasConstants.swapJettonToJetton.forwardGasAmount,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: contractAddress,\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(\n      params.gasAmount ?? this.gasConstants.swapJettonToJetton.gasAmount,\n    );\n\n    return {\n      to: new Address(offerJettonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Build all data required to execute a jetton to ton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `swap` transaction\n   */\n  public async buildSwapJettonToTonTxParams(params: {\n    userWalletAddress: AddressType;\n    offerJettonAddress: AddressType;\n    proxyTonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    referralAddress?: AddressType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    return await this.buildSwapJettonToJettonTxParams({\n      ...params,\n      askJettonAddress: params.proxyTonAddress,\n      gasAmount:\n        params.gasAmount ?? this.gasConstants.swapJettonToTon.gasAmount,\n      forwardGasAmount:\n        params.forwardGasAmount ??\n        this.gasConstants.swapJettonToTon.forwardGasAmount,\n    });\n  }\n\n  /**\n   * Build all data required to execute a ton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; Referral address\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a ton to jetton `swap` transaction\n   */\n  public async buildSwapTonToJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    proxyTonAddress: AddressType;\n    askJettonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    referralAddress?: AddressType | undefined;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [proxyTonWalletAddress, askJettonWalletAddress] = await Promise.all([\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.proxyTonAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.askJettonAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n    ]);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ??\n        this.gasConstants.swapTonToJetton.forwardGasAmount,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: contractAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.offerAmount).add(forwardTonAmount);\n\n    return {\n      to: new Address(proxyTonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  public async createProvideLiquidityBody(params: {\n    routerWalletAddress: AddressType;\n    minLpOut: AmountType;\n  }): Promise<Cell> {\n    const payload = new Cell();\n\n    payload.bits.writeUint(DEX_OP_CODES.PROVIDE_LIQUIDITY, 32);\n    payload.bits.writeAddress(new Address(params.routerWalletAddress));\n    payload.bits.writeCoins(new BN(params.minLpOut));\n\n    return payload;\n  }\n\n  /**\n   * Collect all data required to execute a jetton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `provide_lp` transaction\n   */\n  public async buildProvideLiquidityJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    sendTokenAddress: AddressType;\n    otherTokenAddress: AddressType;\n    sendAmount: AmountType;\n    minLpOut: AmountType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [jettonWalletAddress, routerWalletAddress] = await Promise.all([\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.sendTokenAddress.toString(),\n            ownerAddress: params.userWalletAddress.toString(),\n          }),\n        ))(),\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.otherTokenAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n    ]);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpJetton.forwardGasAmount,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: contractAddress,\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(\n      params.gasAmount ?? this.gasConstants.provideLpJetton.gasAmount,\n    );\n\n    return {\n      to: new Address(jettonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Collect all data required to execute a proxy ton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {BN | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction\n   */\n  public async buildProvideLiquidityTonTxParams(params: {\n    userWalletAddress: AddressType;\n    proxyTonAddress: AddressType;\n    otherTokenAddress: AddressType;\n    sendAmount: AmountType;\n    minLpOut: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const contractAddress = await this.getAddress();\n\n    const [proxyTonWalletAddress, routerWalletAddress] = await Promise.all([\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.proxyTonAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n      (async () =>\n        new Address(\n          await this.stonApiClient.getJettonWalletAddress({\n            jettonAddress: params.otherTokenAddress.toString(),\n            ownerAddress: contractAddress.toString(),\n          }),\n        ))(),\n    ]);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpTon.forwardGasAmount,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: contractAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.sendAmount).add(forwardTonAmount);\n\n    return {\n      to: new Address(proxyTonWalletAddress.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.\n   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.\n   *\n   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton\n   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton\n   *\n   * @returns {Address | null} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddress(params: {\n    token0: AddressType;\n    token1: AddressType;\n  }) {\n    const cellA = new Cell();\n    cellA.bits.writeAddress(new Address(params.token0));\n\n    const cellB = new Cell();\n    cellB.bits.writeAddress(new Address(params.token1));\n\n    const sliceA = bytesToBase64(await cellA.toBoc(false));\n    const sliceB = bytesToBase64(await cellB.toBoc(false));\n\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_pool_address\",\n      [\n        [\"tvm.Slice\", sliceA],\n        [\"tvm.Slice\", sliceB],\n      ],\n    );\n\n    return parseAddress(result);\n  }\n\n  /**\n   * @param {Address | string} params.token0 - The address of the first Jetton minter\n   * @param {Address | string} params.token1 - The address of the second Jetton minter\n   *\n   * @returns {Pool} object for a pool with specified Jetton token addresses.\n   */\n  public async getPool(params: {\n    token0: AddressType;\n    token1: AddressType;\n  }) {\n    const jetton0 = new JettonMinter(\n      this.provider,\n      // @ts-expect-error - not all parameters are really required here\n      {\n        address: params.token0,\n      },\n    );\n\n    const jetton1 = new JettonMinter(\n      this.provider,\n      // @ts-expect-error - not all parameters are really required here\n      {\n        address: params.token1,\n      },\n    );\n\n    const contractAddress = await this.getAddress();\n\n    const [jetton0WalletAddress, jetton1WalletAddress] = await Promise.all([\n      this.stonApiClient.getJettonWalletAddress({\n        jettonAddress: (await jetton0.getAddress()).toString(),\n        ownerAddress: contractAddress.toString(),\n      }),\n      this.stonApiClient.getJettonWalletAddress({\n        jettonAddress: (await jetton1.getAddress()).toString(),\n        ownerAddress: contractAddress.toString(),\n      }),\n    ]);\n\n    const poolAddress = await this.getPoolAddress({\n      token0: jetton0WalletAddress,\n      token1: jetton1WalletAddress,\n    });\n\n    if (!poolAddress) return null;\n\n    return new PoolV1({\n      tonApiClient: this.provider,\n      stonApiClient: this.stonApiClient,\n      address: poolAddress,\n    });\n  }\n\n  /**\n   * @returns current state of the router.\n   */\n  public async getData() {\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_router_data\",\n      [],\n    );\n\n    return {\n      isLocked: parseBoolean(result[0]),\n      adminAddress: parseAddressNotNull(result[1] as Cell),\n      tempUpgrade: result[2] as Cell,\n      poolCode: result[3] as Cell,\n      jettonLpWalletCode: result[4] as Cell,\n      lpAccountCode: result[5] as Cell,\n    };\n  }\n}\n"],"names":["BN","bytesToBase64","Cell","Address","Contract","JettonMinter","TonWeb","_RouterV1","tonApiClient","stonApiClient","gasConstants","options","StonApiClient","params","payload","DEX_OP_CODES","contractAddress","offerJettonWalletAddress","askJettonWalletAddress","forwardPayload","forwardTonAmount","createJettonTransferMessage","gasAmount","proxyTonWalletAddress","jettonWalletAddress","routerWalletAddress","cellA","cellB","sliceA","sliceB","result","parseAddress","jetton0","jetton1","jetton0WalletAddress","jetton1WalletAddress","poolAddress","PoolV1","parseBoolean","parseAddressNotNull","DEX_VERSION","RouterV1"],"mappings":"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"}