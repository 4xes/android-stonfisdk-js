{"version":3,"file":"LpAccountV1.js","sources":["../../../../src/contracts/dex/v1/LpAccountV1.ts"],"sourcesContent":["import TonWeb, { type ContractOptions } from \"tonweb\";\n\nimport type {\n  BN,\n  Cell,\n  MessageData,\n  QueryIdType,\n  AmountType,\n  SdkContractOptions,\n} from \"@/types\";\nimport { StonApiClient } from \"@/StonApiClient\";\nimport { parseAddressNotNull } from \"@/utils/parseAddress\";\n\nimport { DEX_VERSION, DEX_OP_CODES } from \"../constants\";\n\nconst {\n  utils: { BN },\n  boc: { Cell },\n  Contract,\n  Address,\n} = TonWeb;\n\nexport interface LpAccountV1Options\n  extends SdkContractOptions,\n    ContractOptions {\n  address: Required<ContractOptions>[\"address\"];\n  gasConstants?: Partial<typeof LpAccountV1.gasConstants>;\n}\n\n/**\n * The lp account contract holds information about the liquidity provided by the user before minting new liquidity.\n * It interacts only with a single pool contract. For each user, there is single account contract for each pool.\n * The router “routes” the temporary liquidity to the correct account contract.\n * Then the account contract calls the pool contract again to mint new liquidity (once it satisfies some requirements).\n */\nexport class LpAccountV1 extends Contract {\n  public static readonly version = DEX_VERSION.v1;\n  public static readonly gasConstants = {\n    refund: new BN(\"300000000\"),\n    directAddLp: new BN(\"300000000\"),\n    resetGas: new BN(\"300000000\"),\n  };\n\n  protected readonly stonApiClient;\n\n  public readonly gasConstants;\n\n  constructor({\n    tonApiClient,\n    stonApiClient,\n    gasConstants,\n    ...options\n  }: LpAccountV1Options) {\n    super(tonApiClient, options);\n\n    this.stonApiClient = stonApiClient ?? new StonApiClient(tonApiClient);\n    this.gasConstants = {\n      ...LpAccountV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createRefundBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.REFUND, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  }\n\n  /**\n   * Build all data required to execute a `refund_me` transaction.\n   *\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `refund_me` transaction.\n   */\n  public async buildRefundTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createRefundBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.refund);\n\n    return {\n      to: new Address(to.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  public async createDirectAddLiquidityBody(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n    minimumLpToMint?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.DIRECT_ADD_LIQUIDITY, 32);\n    message.bits.writeUint(params.queryId ?? 0, 64);\n    message.bits.writeCoins(new BN(params.amount0));\n    message.bits.writeCoins(new BN(params.amount1));\n    message.bits.writeCoins(new BN(params.minimumLpToMint ?? 1));\n\n    return message;\n  }\n\n  /**\n   * Build all data required to execute a `direct_add_liquidity` transaction.\n   *\n   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)\n   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `direct_add_liquidity` transaction.\n   */\n  public async buildDirectAddLiquidityTxParams(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n    minimumLpToMint?: AmountType;\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createDirectAddLiquidityBody({\n      amount0: params.amount0,\n      amount1: params.amount1,\n      minimumLpToMint: params.minimumLpToMint,\n      queryId: params.queryId,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.directAddLp);\n\n    return {\n      to: new Address(to.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  public async createResetGasBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.RESET_GAS, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  }\n\n  /**\n   * Build all data required to execute a `reset_gas` transaction.\n   *\n   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `reset_gas` transaction.\n   */\n  public async buildResetGasTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createResetGasBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.resetGas);\n\n    return {\n      to: new Address(to.toString(true, true, true)),\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * @returns structure containing current state of the lp account.\n   */\n  public async getData() {\n    const contractAddress = await this.getAddress();\n\n    const result = await this.provider.call2(\n      contractAddress.toString(),\n      \"get_lp_account_data\",\n    );\n\n    return {\n      userAddress: parseAddressNotNull(result[0] as Cell),\n      poolAddress: parseAddressNotNull(result[1] as Cell),\n      amount0: result[2] as BN,\n      amount1: result[3] as BN,\n    };\n  }\n}\n"],"names":["BN","Cell","Contract","Address","TonWeb","_LpAccountV1","tonApiClient","stonApiClient","gasConstants","options","StonApiClient","params","message","DEX_OP_CODES","to","payload","gasAmount","contractAddress","result","parseAddressNotNull","DEX_VERSION","LpAccountV1"],"mappings":"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"}