import g from "tonweb";
import { StonApiClient as p } from "../../../StonApiClient.js";
import { parseAddress as l, parseAddressNotNull as a } from "../../../utils/parseAddress.js";
import { DEX_VERSION as y, DEX_OP_CODES as u } from "../constants.js";
import { LpAccountV1 as h } from "./LpAccountV1.js";
const {
  utils: { BN: i, bytesToBase64: A },
  boc: { Cell: d },
  Address: r,
  token: {
    jetton: { JettonMinter: S, JettonWallet: C }
  }
} = g, c = class w extends S {
  constructor({
    tonApiClient: e,
    stonApiClient: t,
    gasConstants: s,
    ...o
  }) {
    super(
      e,
      // @ts-expect-error - not all parameters are really required here
      o
    ), this.stonApiClient = t ?? new p(e), this.gasConstants = {
      ...w.gasConstants,
      ...s
    };
  }
  async createCollectFeesBody(e) {
    const t = new d();
    return t.bits.writeUint(u.COLLECT_FEES, 32), t.bits.writeUint((e == null ? void 0 : e.queryId) ?? 0, 64), t;
  }
  /**
   * Build all data required to execute a `collect_fees` transaction.
   *
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `collect_fees` transaction.
   */
  async buildCollectFeeTxParams(e) {
    const t = await this.getAddress(), s = await this.createCollectFeesBody({
      queryId: e == null ? void 0 : e.queryId
    }), o = new i(
      (e == null ? void 0 : e.gasAmount) ?? this.gasConstants.collectFees
    );
    return {
      to: new r(t.toString(!0, !0, !0)),
      payload: s,
      gasAmount: o
    };
  }
  async createBurnBody(e) {
    const t = new d();
    return t.bits.writeUint(u.REQUEST_BURN, 32), t.bits.writeUint(e.queryId ?? 0, 64), t.bits.writeCoins(new i(e.amount)), t.bits.writeAddress(new r(e.responseAddress)), t;
  }
  /**
   * Build all data required to execute a `burn` transaction.
   *
   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)
   * @param {Address | string} params.responseAddress - Address of a user
   * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `burn` transaction.
   */
  async buildBurnTxParams(e) {
    const t = await this.getAddress(), [s, o] = await Promise.all([
      (async () => new r(
        await this.stonApiClient.getJettonWalletAddress({
          jettonAddress: t.toString(),
          ownerAddress: e.responseAddress.toString()
        })
      ))(),
      this.createBurnBody({
        amount: e.amount,
        responseAddress: e.responseAddress,
        queryId: e.queryId
      })
    ]), n = new i(e.gasAmount ?? this.gasConstants.burn);
    return {
      to: new r(s.toString(!0, !0, !0)),
      payload: o,
      gasAmount: n
    };
  }
  /**
   * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool
   *
   * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)
   * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)
   *
   * @returns {ExpectedOutputsData} structure with expected result of a token swap
   */
  async getExpectedOutputs(e) {
    const t = new d();
    t.bits.writeAddress(new r(e.jettonWallet));
    const s = A(await t.toBoc(!1)), o = await this.getAddress(), n = await this.provider.call2(
      o.toString(),
      "get_expected_outputs",
      [
        ["int", e.amount.toString()],
        ["tvm.Slice", s]
      ]
    );
    return {
      jettonToReceive: n[0],
      protocolFeePaid: n[1],
      refFeePaid: n[2]
    };
  }
  /**
   * Estimate an expected amount of lp tokens minted when providing liquidity.
   *
   * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)
   * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)
   *
   * @returns {BN} an estimated amount of liquidity tokens to be minted
   */
  async getExpectedTokens(e) {
    const t = await this.getAddress();
    return await this.provider.call2(
      t.toString(),
      "get_expected_tokens",
      [
        ["int", e.amount0.toString()],
        ["int", e.amount1.toString()]
      ]
    );
  }
  /**
   * Estimate expected liquidity freed upon burning liquidity tokens.
   *
   * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)
   *
   * @returns {PoolAmountsData} structure with expected freed liquidity
   */
  async getExpectedLiquidity(e) {
    const t = await this.getAddress(), s = await this.provider.call2(
      t.toString(),
      "get_expected_liquidity",
      [["int", e.jettonAmount.toString()]]
    );
    return {
      amount0: s[0],
      amount1: s[1]
    };
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns the lp account address of a user
   */
  async getLpAccountAddress(e) {
    const t = new d();
    t.bits.writeAddress(new r(e.ownerAddress));
    const s = A(await t.toBoc(!1)), o = await this.getAddress(), n = await this.provider.call2(
      o.toString(),
      "get_lp_account_address",
      [["tvm.Slice", s]]
    );
    return l(n);
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns a JettonWallet object for an address returned by getJettonWalletAddress
   */
  async getJettonWallet(e) {
    const t = await this.stonApiClient.getJettonWalletAddress({
      jettonAddress: (await this.getAddress()).toString(),
      ownerAddress: e.ownerAddress.toString()
    });
    return new C(this.provider, { address: t });
  }
  /**
   * @returns structure containing current state of the pool.
   */
  async getData() {
    const e = await this.getAddress(), t = await this.provider.call2(
      e.toString(),
      "get_pool_data"
    );
    return {
      reserve0: t[0],
      reserve1: t[1],
      token0WalletAddress: a(t[2]),
      token1WalletAddress: a(t[3]),
      lpFee: t[4],
      protocolFee: t[5],
      refFee: t[6],
      protocolFeeAddress: l(t[7]),
      collectedToken0ProtocolFee: t[8],
      collectedToken1ProtocolFee: t[9]
    };
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns {LpAccount} object for address returned by getLpAccountAddress
   */
  async getLpAccount(e) {
    const t = await this.getLpAccountAddress(e);
    return t ? new h({
      tonApiClient: this.provider,
      stonApiClient: this.stonApiClient,
      address: t
    }) : null;
  }
};
c.version = y.v1;
c.gasConstants = {
  collectFees: new i("1100000000"),
  burn: new i("500000000")
};
let E = c;
export {
  E as PoolV1
};
//# sourceMappingURL=PoolV1.js.map
