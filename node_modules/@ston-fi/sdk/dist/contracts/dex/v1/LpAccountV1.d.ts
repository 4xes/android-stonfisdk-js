import { type ContractOptions } from "tonweb";
import type { Cell, MessageData, QueryIdType, AmountType, SdkContractOptions } from '../../../types';
declare const Cell: typeof import("tonweb/dist/types/boc/cell").Cell, Contract: typeof import("tonweb/dist/types/contract/contract").Contract;
export interface LpAccountV1Options extends SdkContractOptions, ContractOptions {
    address: Required<ContractOptions>["address"];
    gasConstants?: Partial<typeof LpAccountV1.gasConstants>;
}
/**
 * The lp account contract holds information about the liquidity provided by the user before minting new liquidity.
 * It interacts only with a single pool contract. For each user, there is single account contract for each pool.
 * The router “routes” the temporary liquidity to the correct account contract.
 * Then the account contract calls the pool contract again to mint new liquidity (once it satisfies some requirements).
 */
export declare class LpAccountV1 extends Contract {
    static readonly version: "v1";
    static readonly gasConstants: {
        refund: import("bn.js");
        directAddLp: import("bn.js");
        resetGas: import("bn.js");
    };
    protected readonly stonApiClient: import('../../../types').StonApiClient;
    readonly gasConstants: {
        refund: import("bn.js");
        directAddLp: import("bn.js");
        resetGas: import("bn.js");
    };
    constructor({ tonApiClient, stonApiClient, gasConstants, ...options }: LpAccountV1Options);
    createRefundBody(params?: {
        queryId?: QueryIdType;
    }): Promise<Cell>;
    /**
     * Build all data required to execute a `refund_me` transaction.
     *
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} all data required to execute a `refund_me` transaction.
     */
    buildRefundTxParams(params?: {
        gasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    createDirectAddLiquidityBody(params: {
        amount0: AmountType;
        amount1: AmountType;
        minimumLpToMint?: AmountType;
        queryId?: QueryIdType;
    }): Promise<Cell>;
    /**
     * Build all data required to execute a `direct_add_liquidity` transaction.
     *
     * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)
     * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)
     * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} all data required to execute a `direct_add_liquidity` transaction.
     */
    buildDirectAddLiquidityTxParams(params: {
        amount0: AmountType;
        amount1: AmountType;
        minimumLpToMint?: AmountType;
        gasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    createResetGasBody(params?: {
        queryId?: QueryIdType;
    }): Promise<Cell>;
    /**
     * Build all data required to execute a `reset_gas` transaction.
     *
     * @param {BN | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} all data required to execute a `reset_gas` transaction.
     */
    buildResetGasTxParams(params?: {
        gasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * @returns structure containing current state of the lp account.
     */
    getData(): Promise<{
        userAddress: import("tonweb/dist/types/utils/address").Address;
        poolAddress: import("tonweb/dist/types/utils/address").Address;
        amount0: import("bn.js");
        amount1: import("bn.js");
    }>;
}
export {};
