{"version":3,"file":"DeserializeDictionary.cjs","sources":["../../../src/utils/parseDictionary/DeserializeDictionary.ts"],"sourcesContent":["import { beginParse, type SliceAdapter as Slice } from \"./SliceAdapter\";\n\n/**\n * Dictionary deserializer from ton-core project\n * https://github.com/ton-community/ton-core/blob/902aa38d568dda04e6f2c2b1aa7d95b8d1e24219/src/dict/parseDict.ts\n */\n\nfunction readUnaryLength(slice: Slice) {\n  let res = 0;\n  while (slice.loadBit()) {\n    res++;\n  }\n  return res;\n}\n\nfunction doParse<V>(\n  prefix: string,\n  slice: Slice,\n  n: number,\n  res: Map<bigint, V>,\n  extractor: (src: Slice) => V,\n) {\n  // Reading label\n  const lb0 = slice.loadBit() ? 1 : 0;\n  let prefixLength = 0;\n  let pp = prefix;\n\n  if (lb0 === 0) {\n    // Short label detected\n\n    // Read\n    prefixLength = readUnaryLength(slice);\n\n    // Read prefix\n    for (let i = 0; i < prefixLength; i++) {\n      pp += slice.loadBit() ? \"1\" : \"0\";\n    }\n  } else {\n    const lb1 = slice.loadBit() ? 1 : 0;\n    if (lb1 === 0) {\n      // Long label detected\n      prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n      for (let i = 0; i < prefixLength; i++) {\n        pp += slice.loadBit() ? \"1\" : \"0\";\n      }\n    } else {\n      // Same label detected\n      const bit = slice.loadBit() ? \"1\" : \"0\";\n      prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n      for (let i = 0; i < prefixLength; i++) {\n        pp += bit;\n      }\n    }\n  }\n\n  if (n - prefixLength === 0) {\n    res.set(BigInt(`0b${pp}`), extractor(slice));\n  } else {\n    const left = slice.loadRef();\n    const right = slice.loadRef();\n\n    // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'\n    if (!left.isExotic) {\n      doParse(`${pp}0`, beginParse(left), n - prefixLength - 1, res, extractor);\n    }\n    if (!right.isExotic) {\n      doParse(\n        `${pp}1`,\n        beginParse(right),\n        n - prefixLength - 1,\n        res,\n        extractor,\n      );\n    }\n  }\n}\n\nexport function parseDict<V>(\n  sc: Slice | null,\n  keySize: number,\n  extractor: (src: Slice) => V,\n) {\n  const res: Map<bigint, V> = new Map();\n  if (sc) {\n    doParse(\"\", sc, keySize, res, extractor);\n  }\n  return res;\n}\n"],"names":["readUnaryLength","slice","res","doParse","prefix","n","extractor","lb0","prefixLength","pp","i","bit","left","right","beginParse","parseDict","sc","keySize"],"mappings":"sHAOA,SAASA,EAAgBC,EAAc,CACrC,IAAIC,EAAM,EACH,KAAAD,EAAM,WACXC,IAEK,OAAAA,CACT,CAEA,SAASC,EACPC,EACAH,EACAI,EACAH,EACAI,EACA,CAEA,MAAMC,EAAMN,EAAM,QAAQ,EAAI,EAAI,EAClC,IAAIO,EAAe,EACfC,EAAKL,EAET,GAAIG,IAAQ,EAAG,CAIbC,EAAeR,EAAgBC,CAAK,EAGpC,QAASS,EAAI,EAAGA,EAAIF,EAAcE,IAC1BD,GAAAR,EAAM,UAAY,IAAM,GAChC,UAEYA,EAAM,QAAQ,EAAI,EAAI,KACtB,EAAG,CAEEO,EAAAP,EAAM,SAAS,KAAK,KAAK,KAAK,KAAKI,EAAI,CAAC,CAAC,CAAC,EACzD,QAASK,EAAI,EAAGA,EAAIF,EAAcE,IAC1BD,GAAAR,EAAM,UAAY,IAAM,GAChC,KACK,CAEL,MAAMU,EAAMV,EAAM,QAAQ,EAAI,IAAM,IACrBO,EAAAP,EAAM,SAAS,KAAK,KAAK,KAAK,KAAKI,EAAI,CAAC,CAAC,CAAC,EACzD,QAASK,EAAI,EAAGA,EAAIF,EAAcE,IAC1BD,GAAAE,CAEV,CAGE,GAAAN,EAAIG,IAAiB,EACnBN,EAAA,IAAI,OAAO,KAAKO,CAAE,EAAE,EAAGH,EAAUL,CAAK,CAAC,MACtC,CACC,MAAAW,EAAOX,EAAM,UACbY,EAAQZ,EAAM,UAGfW,EAAK,UACAT,EAAA,GAAGM,CAAE,IAAKK,EAAAA,WAAWF,CAAI,EAAGP,EAAIG,EAAe,EAAGN,EAAKI,CAAS,EAErEO,EAAM,UACTV,EACE,GAAGM,CAAE,IACLK,EAAAA,WAAWD,CAAK,EAChBR,EAAIG,EAAe,EACnBN,EACAI,CAAA,CAGN,CACF,CAEgB,SAAAS,EACdC,EACAC,EACAX,EACA,CACM,MAAAJ,MAA0B,IAChC,OAAIc,GACFb,EAAQ,GAAIa,EAAIC,EAASf,EAAKI,CAAS,EAElCJ,CACT"}