{"version":3,"file":"DeserializeDictionary.js","sources":["../../../src/utils/parseDictionary/DeserializeDictionary.ts"],"sourcesContent":["import { beginParse, type SliceAdapter as Slice } from \"./SliceAdapter\";\n\n/**\n * Dictionary deserializer from ton-core project\n * https://github.com/ton-community/ton-core/blob/902aa38d568dda04e6f2c2b1aa7d95b8d1e24219/src/dict/parseDict.ts\n */\n\nfunction readUnaryLength(slice: Slice) {\n  let res = 0;\n  while (slice.loadBit()) {\n    res++;\n  }\n  return res;\n}\n\nfunction doParse<V>(\n  prefix: string,\n  slice: Slice,\n  n: number,\n  res: Map<bigint, V>,\n  extractor: (src: Slice) => V,\n) {\n  // Reading label\n  const lb0 = slice.loadBit() ? 1 : 0;\n  let prefixLength = 0;\n  let pp = prefix;\n\n  if (lb0 === 0) {\n    // Short label detected\n\n    // Read\n    prefixLength = readUnaryLength(slice);\n\n    // Read prefix\n    for (let i = 0; i < prefixLength; i++) {\n      pp += slice.loadBit() ? \"1\" : \"0\";\n    }\n  } else {\n    const lb1 = slice.loadBit() ? 1 : 0;\n    if (lb1 === 0) {\n      // Long label detected\n      prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n      for (let i = 0; i < prefixLength; i++) {\n        pp += slice.loadBit() ? \"1\" : \"0\";\n      }\n    } else {\n      // Same label detected\n      const bit = slice.loadBit() ? \"1\" : \"0\";\n      prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));\n      for (let i = 0; i < prefixLength; i++) {\n        pp += bit;\n      }\n    }\n  }\n\n  if (n - prefixLength === 0) {\n    res.set(BigInt(`0b${pp}`), extractor(slice));\n  } else {\n    const left = slice.loadRef();\n    const right = slice.loadRef();\n\n    // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'\n    if (!left.isExotic) {\n      doParse(`${pp}0`, beginParse(left), n - prefixLength - 1, res, extractor);\n    }\n    if (!right.isExotic) {\n      doParse(\n        `${pp}1`,\n        beginParse(right),\n        n - prefixLength - 1,\n        res,\n        extractor,\n      );\n    }\n  }\n}\n\nexport function parseDict<V>(\n  sc: Slice | null,\n  keySize: number,\n  extractor: (src: Slice) => V,\n) {\n  const res: Map<bigint, V> = new Map();\n  if (sc) {\n    doParse(\"\", sc, keySize, res, extractor);\n  }\n  return res;\n}\n"],"names":["readUnaryLength","slice","res","doParse","prefix","n","extractor","lb0","prefixLength","pp","i","bit","left","right","beginParse","parseDict","sc","keySize"],"mappings":";AAOA,SAASA,EAAgBC,GAAc;AACrC,MAAIC,IAAM;AACH,SAAAD,EAAM;AACX,IAAAC;AAEK,SAAAA;AACT;AAEA,SAASC,EACPC,GACAH,GACAI,GACAH,GACAI,GACA;AAEA,QAAMC,IAAMN,EAAM,QAAQ,IAAI,IAAI;AAClC,MAAIO,IAAe,GACfC,IAAKL;AAET,MAAIG,MAAQ,GAAG;AAIb,IAAAC,IAAeR,EAAgBC,CAAK;AAGpC,aAASS,IAAI,GAAGA,IAAIF,GAAcE;AAC1B,MAAAD,KAAAR,EAAM,YAAY,MAAM;AAAA,EAChC,YAEYA,EAAM,QAAQ,IAAI,IAAI,OACtB,GAAG;AAEE,IAAAO,IAAAP,EAAM,SAAS,KAAK,KAAK,KAAK,KAAKI,IAAI,CAAC,CAAC,CAAC;AACzD,aAASK,IAAI,GAAGA,IAAIF,GAAcE;AAC1B,MAAAD,KAAAR,EAAM,YAAY,MAAM;AAAA,EAChC,OACK;AAEL,UAAMU,IAAMV,EAAM,QAAQ,IAAI,MAAM;AACrB,IAAAO,IAAAP,EAAM,SAAS,KAAK,KAAK,KAAK,KAAKI,IAAI,CAAC,CAAC,CAAC;AACzD,aAASK,IAAI,GAAGA,IAAIF,GAAcE;AAC1B,MAAAD,KAAAE;AAAA,EAEV;AAGE,MAAAN,IAAIG,MAAiB;AACnB,IAAAN,EAAA,IAAI,OAAO,KAAKO,CAAE,EAAE,GAAGH,EAAUL,CAAK,CAAC;AAAA,OACtC;AACC,UAAAW,IAAOX,EAAM,WACbY,IAAQZ,EAAM;AAGhB,IAACW,EAAK,YACAT,EAAA,GAAGM,CAAE,KAAKK,EAAWF,CAAI,GAAGP,IAAIG,IAAe,GAAGN,GAAKI,CAAS,GAErEO,EAAM,YACTV;AAAA,MACE,GAAGM,CAAE;AAAA,MACLK,EAAWD,CAAK;AAAA,MAChBR,IAAIG,IAAe;AAAA,MACnBN;AAAA,MACAI;AAAA,IAAA;AAAA,EAGN;AACF;AAEgB,SAAAS,EACdC,GACAC,GACAX,GACA;AACM,QAAAJ,wBAA0B;AAChC,SAAIc,KACFb,EAAQ,IAAIa,GAAIC,GAASf,GAAKI,CAAS,GAElCJ;AACT;"}